"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.IdentityApiClientImpl = exports.GetInboxIdsResponse_Response = exports.GetInboxIdsResponse = exports.GetInboxIdsRequest_Request = exports.GetInboxIdsRequest = exports.GetIdentityUpdatesResponse_Response = exports.GetIdentityUpdatesResponse_IdentityUpdateLog = exports.GetIdentityUpdatesResponse = exports.GetIdentityUpdatesRequest_Request = exports.GetIdentityUpdatesRequest = exports.PublishIdentityUpdateResponse = exports.PublishIdentityUpdateRequest = exports.VerifySmartContractWalletSignaturesResponse_ValidationResponse = exports.VerifySmartContractWalletSignaturesResponse = exports.VerifySmartContractWalletSignatureRequestSignature = exports.VerifySmartContractWalletSignaturesRequest = exports.protobufPackage = void 0;
/* eslint-disable */
const long_1 = __importDefault(require("long"));
const association_pb_1 = require("../../associations/association.pb");
const minimal_1 = __importDefault(require("protobufjs/minimal"));
exports.protobufPackage = "xmtp.identity.api.v1";
function createBaseVerifySmartContractWalletSignaturesRequest() {
    return { signatures: [] };
}
exports.VerifySmartContractWalletSignaturesRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.signatures) {
            exports.VerifySmartContractWalletSignatureRequestSignature.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseVerifySmartContractWalletSignaturesRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.signatures.push(exports.VerifySmartContractWalletSignatureRequestSignature.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            signatures: Array.isArray(object === null || object === void 0 ? void 0 : object.signatures)
                ? object.signatures.map((e) => exports.VerifySmartContractWalletSignatureRequestSignature.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.signatures) {
            obj.signatures = message.signatures.map((e) => e
                ? exports.VerifySmartContractWalletSignatureRequestSignature.toJSON(e)
                : undefined);
        }
        else {
            obj.signatures = [];
        }
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = createBaseVerifySmartContractWalletSignaturesRequest();
        message.signatures =
            ((_a = object.signatures) === null || _a === void 0 ? void 0 : _a.map((e) => exports.VerifySmartContractWalletSignatureRequestSignature.fromPartial(e))) || [];
        return message;
    },
};
function createBaseVerifySmartContractWalletSignatureRequestSignature() {
    return {
        accountId: "",
        blockNumber: undefined,
        signature: new Uint8Array(),
        hash: new Uint8Array(),
    };
}
exports.VerifySmartContractWalletSignatureRequestSignature = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.accountId !== "") {
            writer.uint32(10).string(message.accountId);
        }
        if (message.blockNumber !== undefined) {
            writer.uint32(16).uint64(message.blockNumber);
        }
        if (message.signature.length !== 0) {
            writer.uint32(26).bytes(message.signature);
        }
        if (message.hash.length !== 0) {
            writer.uint32(34).bytes(message.hash);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseVerifySmartContractWalletSignatureRequestSignature();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.accountId = reader.string();
                    break;
                case 2:
                    message.blockNumber = reader.uint64();
                    break;
                case 3:
                    message.signature = reader.bytes();
                    break;
                case 4:
                    message.hash = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            accountId: isSet(object.accountId) ? String(object.accountId) : "",
            blockNumber: isSet(object.blockNumber)
                ? long_1.default.fromValue(object.blockNumber)
                : undefined,
            signature: isSet(object.signature)
                ? bytesFromBase64(object.signature)
                : new Uint8Array(),
            hash: isSet(object.hash)
                ? bytesFromBase64(object.hash)
                : new Uint8Array(),
        };
    },
    toJSON(message) {
        const obj = {};
        message.accountId !== undefined && (obj.accountId = message.accountId);
        message.blockNumber !== undefined &&
            (obj.blockNumber = (message.blockNumber || undefined).toString());
        message.signature !== undefined &&
            (obj.signature = base64FromBytes(message.signature !== undefined ? message.signature : new Uint8Array()));
        message.hash !== undefined &&
            (obj.hash = base64FromBytes(message.hash !== undefined ? message.hash : new Uint8Array()));
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseVerifySmartContractWalletSignatureRequestSignature();
        message.accountId = (_a = object.accountId) !== null && _a !== void 0 ? _a : "";
        message.blockNumber =
            object.blockNumber !== undefined && object.blockNumber !== null
                ? long_1.default.fromValue(object.blockNumber)
                : undefined;
        message.signature = (_b = object.signature) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.hash = (_c = object.hash) !== null && _c !== void 0 ? _c : new Uint8Array();
        return message;
    },
};
function createBaseVerifySmartContractWalletSignaturesResponse() {
    return { responses: [] };
}
exports.VerifySmartContractWalletSignaturesResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.responses) {
            exports.VerifySmartContractWalletSignaturesResponse_ValidationResponse.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseVerifySmartContractWalletSignaturesResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.responses.push(exports.VerifySmartContractWalletSignaturesResponse_ValidationResponse.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            responses: Array.isArray(object === null || object === void 0 ? void 0 : object.responses)
                ? object.responses.map((e) => exports.VerifySmartContractWalletSignaturesResponse_ValidationResponse.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.responses) {
            obj.responses = message.responses.map((e) => e
                ? exports.VerifySmartContractWalletSignaturesResponse_ValidationResponse.toJSON(e)
                : undefined);
        }
        else {
            obj.responses = [];
        }
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = createBaseVerifySmartContractWalletSignaturesResponse();
        message.responses =
            ((_a = object.responses) === null || _a === void 0 ? void 0 : _a.map((e) => exports.VerifySmartContractWalletSignaturesResponse_ValidationResponse.fromPartial(e))) || [];
        return message;
    },
};
function createBaseVerifySmartContractWalletSignaturesResponse_ValidationResponse() {
    return { isValid: false, blockNumber: undefined, error: undefined };
}
exports.VerifySmartContractWalletSignaturesResponse_ValidationResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.isValid === true) {
            writer.uint32(8).bool(message.isValid);
        }
        if (message.blockNumber !== undefined) {
            writer.uint32(16).uint64(message.blockNumber);
        }
        if (message.error !== undefined) {
            writer.uint32(26).string(message.error);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseVerifySmartContractWalletSignaturesResponse_ValidationResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.isValid = reader.bool();
                    break;
                case 2:
                    message.blockNumber = reader.uint64();
                    break;
                case 3:
                    message.error = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            isValid: isSet(object.isValid) ? Boolean(object.isValid) : false,
            blockNumber: isSet(object.blockNumber)
                ? long_1.default.fromValue(object.blockNumber)
                : undefined,
            error: isSet(object.error) ? String(object.error) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.isValid !== undefined && (obj.isValid = message.isValid);
        message.blockNumber !== undefined &&
            (obj.blockNumber = (message.blockNumber || undefined).toString());
        message.error !== undefined && (obj.error = message.error);
        return obj;
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseVerifySmartContractWalletSignaturesResponse_ValidationResponse();
        message.isValid = (_a = object.isValid) !== null && _a !== void 0 ? _a : false;
        message.blockNumber =
            object.blockNumber !== undefined && object.blockNumber !== null
                ? long_1.default.fromValue(object.blockNumber)
                : undefined;
        message.error = (_b = object.error) !== null && _b !== void 0 ? _b : undefined;
        return message;
    },
};
function createBasePublishIdentityUpdateRequest() {
    return { identityUpdate: undefined };
}
exports.PublishIdentityUpdateRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.identityUpdate !== undefined) {
            association_pb_1.IdentityUpdate.encode(message.identityUpdate, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePublishIdentityUpdateRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.identityUpdate = association_pb_1.IdentityUpdate.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            identityUpdate: isSet(object.identityUpdate)
                ? association_pb_1.IdentityUpdate.fromJSON(object.identityUpdate)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.identityUpdate !== undefined &&
            (obj.identityUpdate = message.identityUpdate
                ? association_pb_1.IdentityUpdate.toJSON(message.identityUpdate)
                : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBasePublishIdentityUpdateRequest();
        message.identityUpdate =
            object.identityUpdate !== undefined && object.identityUpdate !== null
                ? association_pb_1.IdentityUpdate.fromPartial(object.identityUpdate)
                : undefined;
        return message;
    },
};
function createBasePublishIdentityUpdateResponse() {
    return {};
}
exports.PublishIdentityUpdateResponse = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePublishIdentityUpdateResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    fromPartial(_) {
        const message = createBasePublishIdentityUpdateResponse();
        return message;
    },
};
function createBaseGetIdentityUpdatesRequest() {
    return { requests: [] };
}
exports.GetIdentityUpdatesRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.requests) {
            exports.GetIdentityUpdatesRequest_Request.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetIdentityUpdatesRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.requests.push(exports.GetIdentityUpdatesRequest_Request.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            requests: Array.isArray(object === null || object === void 0 ? void 0 : object.requests)
                ? object.requests.map((e) => exports.GetIdentityUpdatesRequest_Request.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.requests) {
            obj.requests = message.requests.map((e) => e ? exports.GetIdentityUpdatesRequest_Request.toJSON(e) : undefined);
        }
        else {
            obj.requests = [];
        }
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = createBaseGetIdentityUpdatesRequest();
        message.requests =
            ((_a = object.requests) === null || _a === void 0 ? void 0 : _a.map((e) => exports.GetIdentityUpdatesRequest_Request.fromPartial(e))) || [];
        return message;
    },
};
function createBaseGetIdentityUpdatesRequest_Request() {
    return { inboxId: "", sequenceId: long_1.default.UZERO };
}
exports.GetIdentityUpdatesRequest_Request = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.inboxId !== "") {
            writer.uint32(10).string(message.inboxId);
        }
        if (!message.sequenceId.isZero()) {
            writer.uint32(16).uint64(message.sequenceId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetIdentityUpdatesRequest_Request();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.inboxId = reader.string();
                    break;
                case 2:
                    message.sequenceId = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            inboxId: isSet(object.inboxId) ? String(object.inboxId) : "",
            sequenceId: isSet(object.sequenceId)
                ? long_1.default.fromValue(object.sequenceId)
                : long_1.default.UZERO,
        };
    },
    toJSON(message) {
        const obj = {};
        message.inboxId !== undefined && (obj.inboxId = message.inboxId);
        message.sequenceId !== undefined &&
            (obj.sequenceId = (message.sequenceId || long_1.default.UZERO).toString());
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = createBaseGetIdentityUpdatesRequest_Request();
        message.inboxId = (_a = object.inboxId) !== null && _a !== void 0 ? _a : "";
        message.sequenceId =
            object.sequenceId !== undefined && object.sequenceId !== null
                ? long_1.default.fromValue(object.sequenceId)
                : long_1.default.UZERO;
        return message;
    },
};
function createBaseGetIdentityUpdatesResponse() {
    return { responses: [] };
}
exports.GetIdentityUpdatesResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.responses) {
            exports.GetIdentityUpdatesResponse_Response.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetIdentityUpdatesResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.responses.push(exports.GetIdentityUpdatesResponse_Response.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            responses: Array.isArray(object === null || object === void 0 ? void 0 : object.responses)
                ? object.responses.map((e) => exports.GetIdentityUpdatesResponse_Response.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.responses) {
            obj.responses = message.responses.map((e) => e ? exports.GetIdentityUpdatesResponse_Response.toJSON(e) : undefined);
        }
        else {
            obj.responses = [];
        }
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = createBaseGetIdentityUpdatesResponse();
        message.responses =
            ((_a = object.responses) === null || _a === void 0 ? void 0 : _a.map((e) => exports.GetIdentityUpdatesResponse_Response.fromPartial(e))) || [];
        return message;
    },
};
function createBaseGetIdentityUpdatesResponse_IdentityUpdateLog() {
    return {
        sequenceId: long_1.default.UZERO,
        serverTimestampNs: long_1.default.UZERO,
        update: undefined,
    };
}
exports.GetIdentityUpdatesResponse_IdentityUpdateLog = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.sequenceId.isZero()) {
            writer.uint32(8).uint64(message.sequenceId);
        }
        if (!message.serverTimestampNs.isZero()) {
            writer.uint32(16).uint64(message.serverTimestampNs);
        }
        if (message.update !== undefined) {
            association_pb_1.IdentityUpdate.encode(message.update, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetIdentityUpdatesResponse_IdentityUpdateLog();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.sequenceId = reader.uint64();
                    break;
                case 2:
                    message.serverTimestampNs = reader.uint64();
                    break;
                case 3:
                    message.update = association_pb_1.IdentityUpdate.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            sequenceId: isSet(object.sequenceId)
                ? long_1.default.fromValue(object.sequenceId)
                : long_1.default.UZERO,
            serverTimestampNs: isSet(object.serverTimestampNs)
                ? long_1.default.fromValue(object.serverTimestampNs)
                : long_1.default.UZERO,
            update: isSet(object.update)
                ? association_pb_1.IdentityUpdate.fromJSON(object.update)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.sequenceId !== undefined &&
            (obj.sequenceId = (message.sequenceId || long_1.default.UZERO).toString());
        message.serverTimestampNs !== undefined &&
            (obj.serverTimestampNs = (message.serverTimestampNs || long_1.default.UZERO).toString());
        message.update !== undefined &&
            (obj.update = message.update
                ? association_pb_1.IdentityUpdate.toJSON(message.update)
                : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseGetIdentityUpdatesResponse_IdentityUpdateLog();
        message.sequenceId =
            object.sequenceId !== undefined && object.sequenceId !== null
                ? long_1.default.fromValue(object.sequenceId)
                : long_1.default.UZERO;
        message.serverTimestampNs =
            object.serverTimestampNs !== undefined &&
                object.serverTimestampNs !== null
                ? long_1.default.fromValue(object.serverTimestampNs)
                : long_1.default.UZERO;
        message.update =
            object.update !== undefined && object.update !== null
                ? association_pb_1.IdentityUpdate.fromPartial(object.update)
                : undefined;
        return message;
    },
};
function createBaseGetIdentityUpdatesResponse_Response() {
    return { inboxId: "", updates: [] };
}
exports.GetIdentityUpdatesResponse_Response = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.inboxId !== "") {
            writer.uint32(10).string(message.inboxId);
        }
        for (const v of message.updates) {
            exports.GetIdentityUpdatesResponse_IdentityUpdateLog.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetIdentityUpdatesResponse_Response();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.inboxId = reader.string();
                    break;
                case 2:
                    message.updates.push(exports.GetIdentityUpdatesResponse_IdentityUpdateLog.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            inboxId: isSet(object.inboxId) ? String(object.inboxId) : "",
            updates: Array.isArray(object === null || object === void 0 ? void 0 : object.updates)
                ? object.updates.map((e) => exports.GetIdentityUpdatesResponse_IdentityUpdateLog.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        message.inboxId !== undefined && (obj.inboxId = message.inboxId);
        if (message.updates) {
            obj.updates = message.updates.map((e) => e ? exports.GetIdentityUpdatesResponse_IdentityUpdateLog.toJSON(e) : undefined);
        }
        else {
            obj.updates = [];
        }
        return obj;
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseGetIdentityUpdatesResponse_Response();
        message.inboxId = (_a = object.inboxId) !== null && _a !== void 0 ? _a : "";
        message.updates =
            ((_b = object.updates) === null || _b === void 0 ? void 0 : _b.map((e) => exports.GetIdentityUpdatesResponse_IdentityUpdateLog.fromPartial(e))) || [];
        return message;
    },
};
function createBaseGetInboxIdsRequest() {
    return { requests: [] };
}
exports.GetInboxIdsRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.requests) {
            exports.GetInboxIdsRequest_Request.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetInboxIdsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.requests.push(exports.GetInboxIdsRequest_Request.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            requests: Array.isArray(object === null || object === void 0 ? void 0 : object.requests)
                ? object.requests.map((e) => exports.GetInboxIdsRequest_Request.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.requests) {
            obj.requests = message.requests.map((e) => e ? exports.GetInboxIdsRequest_Request.toJSON(e) : undefined);
        }
        else {
            obj.requests = [];
        }
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = createBaseGetInboxIdsRequest();
        message.requests =
            ((_a = object.requests) === null || _a === void 0 ? void 0 : _a.map((e) => exports.GetInboxIdsRequest_Request.fromPartial(e))) ||
                [];
        return message;
    },
};
function createBaseGetInboxIdsRequest_Request() {
    return { address: "" };
}
exports.GetInboxIdsRequest_Request = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.address !== "") {
            writer.uint32(10).string(message.address);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetInboxIdsRequest_Request();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.address = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            address: isSet(object.address) ? String(object.address) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.address !== undefined && (obj.address = message.address);
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = createBaseGetInboxIdsRequest_Request();
        message.address = (_a = object.address) !== null && _a !== void 0 ? _a : "";
        return message;
    },
};
function createBaseGetInboxIdsResponse() {
    return { responses: [] };
}
exports.GetInboxIdsResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.responses) {
            exports.GetInboxIdsResponse_Response.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetInboxIdsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.responses.push(exports.GetInboxIdsResponse_Response.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            responses: Array.isArray(object === null || object === void 0 ? void 0 : object.responses)
                ? object.responses.map((e) => exports.GetInboxIdsResponse_Response.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.responses) {
            obj.responses = message.responses.map((e) => e ? exports.GetInboxIdsResponse_Response.toJSON(e) : undefined);
        }
        else {
            obj.responses = [];
        }
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = createBaseGetInboxIdsResponse();
        message.responses =
            ((_a = object.responses) === null || _a === void 0 ? void 0 : _a.map((e) => exports.GetInboxIdsResponse_Response.fromPartial(e))) || [];
        return message;
    },
};
function createBaseGetInboxIdsResponse_Response() {
    return { address: "", inboxId: undefined };
}
exports.GetInboxIdsResponse_Response = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.address !== "") {
            writer.uint32(10).string(message.address);
        }
        if (message.inboxId !== undefined) {
            writer.uint32(18).string(message.inboxId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetInboxIdsResponse_Response();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.address = reader.string();
                    break;
                case 2:
                    message.inboxId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            address: isSet(object.address) ? String(object.address) : "",
            inboxId: isSet(object.inboxId) ? String(object.inboxId) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.address !== undefined && (obj.address = message.address);
        message.inboxId !== undefined && (obj.inboxId = message.inboxId);
        return obj;
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseGetInboxIdsResponse_Response();
        message.address = (_a = object.address) !== null && _a !== void 0 ? _a : "";
        message.inboxId = (_b = object.inboxId) !== null && _b !== void 0 ? _b : undefined;
        return message;
    },
};
class IdentityApiClientImpl {
    constructor(rpc) {
        this.rpc = rpc;
        this.PublishIdentityUpdate = this.PublishIdentityUpdate.bind(this);
        this.GetIdentityUpdates = this.GetIdentityUpdates.bind(this);
        this.GetInboxIds = this.GetInboxIds.bind(this);
        this.VerifySmartContractWalletSignatures =
            this.VerifySmartContractWalletSignatures.bind(this);
    }
    PublishIdentityUpdate(request) {
        const data = exports.PublishIdentityUpdateRequest.encode(request).finish();
        const promise = this.rpc.request("xmtp.identity.api.v1.IdentityApi", "PublishIdentityUpdate", data);
        return promise.then((data) => exports.PublishIdentityUpdateResponse.decode(new minimal_1.default.Reader(data)));
    }
    GetIdentityUpdates(request) {
        const data = exports.GetIdentityUpdatesRequest.encode(request).finish();
        const promise = this.rpc.request("xmtp.identity.api.v1.IdentityApi", "GetIdentityUpdates", data);
        return promise.then((data) => exports.GetIdentityUpdatesResponse.decode(new minimal_1.default.Reader(data)));
    }
    GetInboxIds(request) {
        const data = exports.GetInboxIdsRequest.encode(request).finish();
        const promise = this.rpc.request("xmtp.identity.api.v1.IdentityApi", "GetInboxIds", data);
        return promise.then((data) => exports.GetInboxIdsResponse.decode(new minimal_1.default.Reader(data)));
    }
    VerifySmartContractWalletSignatures(request) {
        const data = exports.VerifySmartContractWalletSignaturesRequest.encode(request).finish();
        const promise = this.rpc.request("xmtp.identity.api.v1.IdentityApi", "VerifySmartContractWalletSignatures", data);
        return promise.then((data) => exports.VerifySmartContractWalletSignaturesResponse.decode(new minimal_1.default.Reader(data)));
    }
}
exports.IdentityApiClientImpl = IdentityApiClientImpl;
var globalThis = (() => {
    if (typeof globalThis !== "undefined")
        return globalThis;
    if (typeof self !== "undefined")
        return self;
    if (typeof window !== "undefined")
        return window;
    if (typeof global !== "undefined")
        return global;
    throw "Unable to locate global object";
})();
function bytesFromBase64(b64) {
    if (globalThis.Buffer) {
        return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
    }
    else {
        const bin = globalThis.atob(b64);
        const arr = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; ++i) {
            arr[i] = bin.charCodeAt(i);
        }
        return arr;
    }
}
function base64FromBytes(arr) {
    if (globalThis.Buffer) {
        return globalThis.Buffer.from(arr).toString("base64");
    }
    else {
        const bin = [];
        arr.forEach((byte) => {
            bin.push(String.fromCharCode(byte));
        });
        return globalThis.btoa(bin.join(""));
    }
}
if (minimal_1.default.util.Long !== long_1.default) {
    minimal_1.default.util.Long = long_1.default;
    minimal_1.default.configure();
}
function isSet(value) {
    return value !== null && value !== undefined;
}
//# sourceMappingURL=identity.pb.js.map