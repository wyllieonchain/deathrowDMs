import{ciphertext as e,privateKey as t,signature as s,publicKey as n,fetcher as r,keystore as i,message as a,content as o,authn as c,messageApi as d,invitation as h,contact as y,privatePreferences as u}from"@xmtp/proto";import l from"long";import*as p from"@noble/secp256k1";import{bytesToHex as w,keccak256 as f,getAddress as m,hexToSignature as g,hexToBytes as v,hashMessage as b,verifyMessage as E}from"viem";import{ContentTypeText as K,TextCodec as A}from"@xmtp/content-type-text";import{ContentTypeId as k}from"@xmtp/content-type-primitives";import{Mutex as T}from"async-mutex";import S from"elliptic";import C,{user_preferences_encrypt as P,user_preferences_decrypt as B,generate_private_preferences_topic as I}from"@xmtp/user-preferences-bindings-wasm/web";import{createConsentMessage as R}from"@xmtp/consent-proof-signature";class N{constructor(e){if(!e.aes256GcmHkdfSha256)throw new Error("invalid ciphertext");if(e.aes256GcmHkdfSha256.payload.length<16)throw new Error(`invalid ciphertext ciphertext length: ${e.aes256GcmHkdfSha256.payload.length}`);if(32!==e.aes256GcmHkdfSha256.hkdfSalt.length)throw new Error(`invalid ciphertext salt length: ${e.aes256GcmHkdfSha256.hkdfSalt.length}`);if(12!==e.aes256GcmHkdfSha256.gcmNonce.length)throw new Error(`invalid ciphertext nonce length: ${e.aes256GcmHkdfSha256.gcmNonce.length}`);this.aes256GcmHkdfSha256=e.aes256GcmHkdfSha256}toBytes(){return e.Ciphertext.encode(this).finish()}static fromBytes(t){return new N(e.Ciphertext.decode(t))}}const D=window.crypto,M=(new Uint8Array).buffer,_=(new Uint8Array).buffer;async function x(e){return new Uint8Array(await D.subtle.digest("SHA-256",e))}async function V(e,t,s){const n=D.getRandomValues(new Uint8Array(32)),r=D.getRandomValues(new Uint8Array(12)),i=await O(t,n),a=await D.subtle.encrypt(q(r,s),i,e);return new N({aes256GcmHkdfSha256:{payload:new Uint8Array(a),hkdfSalt:n,gcmNonce:r}})}async function U(e,t,s){if(!e.aes256GcmHkdfSha256)throw new Error("invalid payload ciphertext");const n=await O(t,e.aes256GcmHkdfSha256.hkdfSalt),r=await D.subtle.decrypt(q(e.aes256GcmHkdfSha256.gcmNonce,s),n,e.aes256GcmHkdfSha256.payload);return new Uint8Array(r)}function q(e,t){const s={name:"AES-GCM",iv:e};return t&&(s.additionalData=t),s}async function O(e,t){const s=await D.subtle.importKey("raw",e,"HKDF",!1,["deriveKey"]);return D.subtle.deriveKey({name:"HKDF",hash:"SHA-256",salt:t,info:M},s,{name:"AES-GCM",length:256},!1,["encrypt","decrypt"])}async function L(e,t){const s=await D.subtle.importKey("raw",e,"HKDF",!1,["deriveKey"]);return D.subtle.deriveKey({name:"HKDF",hash:"SHA-256",salt:_,info:t},s,{name:"HMAC",hash:"SHA-256",length:256},!0,["sign","verify"])}async function H(e,t,s){const n=await L(e,t),r=await D.subtle.sign("HMAC",n,s);return new Uint8Array(r)}async function F(e,t,s){return await D.subtle.verify("HMAC",e,t,s)}async function G(e){const t=await D.subtle.exportKey("raw",e);return new Uint8Array(t)}async function $(e){return D.subtle.importKey("raw",e,{name:"HMAC",hash:"SHA-256",length:256},!0,["sign","verify"])}const j=p.utils.bytesToHex;function X(e,t){if(e.length!==t.length)return!1;for(let s=0;s<e.length;s++)if(e[s]!==t[s])return!1;return!0}function J(e){const t=g(e),s=v(t.r),n=v(t.s);let r=Number(t.v);0!==r&&1!==r||(r+=27);const i=1-r%2,a=new Uint8Array(64);return a.set(s),a.set(n,s.length),{bytes:a,recovery:i}}function z(e){if(32!==e.bytes.length)throw new Error(`invalid private key length: ${e.bytes.length}`)}class Y{constructor(e){if(!e.secp256k1)throw new Error("invalid private key");if(z(e.secp256k1),this.secp256k1=e.secp256k1,this.createdNs=e.createdNs,!e.publicKey)throw new Error("missing public key");this.publicKey=new ae(e.publicKey)}static async generate(e){const t={bytes:p.utils.randomPrivateKey()},s=l.fromNumber((new Date).getTime()).mul(1e6),n=new ie({secp256k1Uncompressed:{bytes:p.getPublicKey(t.bytes)},createdNs:s}),r=await e.signKey(n);return new Y({secp256k1:t,createdNs:s,publicKey:r})}generated(){return new Date(this.createdNs.div(1e6).toNumber())}async sign(e){const[t,s]=await p.sign(e,this.secp256k1.bytes,{recovered:!0,der:!1});return new te({ecdsaCompact:{bytes:t,recovery:s}})}async signKey(e){const t=e.toBytes(),s=await x(t),n=await this.sign(s);return new ae({keyBytes:t,signature:n})}static async signerKey(e,t){return ee(await x(e.bytesToSign()),t)}sharedSecret(e){return p.getSharedSecret(this.secp256k1.bytes,e.secp256k1Uncompressed.bytes,!1)}encrypt(e,t,s){return V(e,this.sharedSecret(t),s)}decrypt(e,t,s){return U(e,this.sharedSecret(t),s)}matches(e){return this.publicKey.equals(e)}equals(e){return X(this.secp256k1.bytes,e.secp256k1.bytes)&&this.publicKey.equals(e.publicKey)}toBytes(){return t.SignedPrivateKey.encode(this).finish()}validatePublicKey(){return X(p.getPublicKey(this.secp256k1.bytes),this.publicKey.secp256k1Uncompressed.bytes)}static fromBytes(e){return new Y(t.SignedPrivateKey.decode(e))}static fromLegacyKey(e,t){return new Y({createdNs:e.timestamp.mul(1e6),secp256k1:e.secp256k1,publicKey:ae.fromLegacyKey(e.publicKey,t)})}}class W{constructor(e){if(!e.secp256k1)throw new Error("invalid private key");if(z(e.secp256k1),this.timestamp=e.timestamp,this.secp256k1=e.secp256k1,!e.publicKey)throw new Error("missing public key");this.publicKey=new oe(e.publicKey)}static generate(){const e={bytes:p.utils.randomPrivateKey()},t=l.fromNumber((new Date).getTime());return new W({secp256k1:e,timestamp:t,publicKey:new oe({secp256k1Uncompressed:{bytes:p.getPublicKey(e.bytes)},timestamp:t})})}generated(){return new Date(this.timestamp.toNumber())}async sign(e){const[t,s]=await p.sign(e,this.secp256k1.bytes,{recovered:!0,der:!1});return new te({ecdsaCompact:{bytes:t,recovery:s}})}async signKey(e){const t=await x(e.bytesToSign());return e.signature=await this.sign(t),e}sharedSecret(e){return p.getSharedSecret(this.secp256k1.bytes,e.secp256k1Uncompressed.bytes,!1)}encrypt(e,t,s){return V(e,this.sharedSecret(t),s)}decrypt(e,t,s){return U(e,this.sharedSecret(t),s)}matches(e){return this.publicKey.equals(e)}validatePublicKey(){return X(p.getPublicKey(this.secp256k1.bytes),this.publicKey.secp256k1Uncompressed.bytes)}toBytes(){return t.PrivateKey.encode(this).finish()}static fromBytes(e){return new W(t.PrivateKey.decode(e))}}function Q(e){if(64!==e.bytes.length)throw new Error(`invalid signature length: ${e.bytes.length}`);if(0!==e.recovery&&1!==e.recovery)throw new Error(`invalid recovery bit: ${e.recovery}`)}function Z(e,t){return e.recovery===t.recovery&&X(e.bytes,t.bytes)}function ee(e,t){const s=p.recoverPublicKey(e,t.bytes,t.recovery);return s?new ie({secp256k1Uncompressed:{bytes:s},createdNs:l.fromNumber(0)}):void 0}class te{constructor(e){if(e.ecdsaCompact)Q(e.ecdsaCompact),this.ecdsaCompact=e.ecdsaCompact;else{if(!e.walletEcdsaCompact)throw new Error("invalid signature");Q(e.walletEcdsaCompact),this.walletEcdsaCompact=e.walletEcdsaCompact}}async signerKey(e){return this.ecdsaCompact?Y.signerKey(e,this.ecdsaCompact):this.walletEcdsaCompact?ne.signerKey(e,this.walletEcdsaCompact):void 0}getPublicKey(e){let t;if(this.ecdsaCompact)t=p.recoverPublicKey(e,this.ecdsaCompact.bytes,this.ecdsaCompact.recovery);else{if(!this.walletEcdsaCompact)throw new Error("invalid v1 signature");t=p.recoverPublicKey(e,this.walletEcdsaCompact.bytes,this.walletEcdsaCompact.recovery)}return t?new oe({secp256k1Uncompressed:{bytes:t},timestamp:l.fromNumber(0)}):void 0}equals(e){return this.ecdsaCompact&&e.ecdsaCompact?Z(this.ecdsaCompact,e.ecdsaCompact):!(!this.walletEcdsaCompact||!e.walletEcdsaCompact)&&Z(this.walletEcdsaCompact,e.walletEcdsaCompact)}toBytes(){return s.Signature.encode(this).finish()}static fromBytes(e){return new te(s.Signature.decode(e))}}var se;!function(e){e[e.INBOX_KEY=0]="INBOX_KEY",e[e.SEND_KEY=1]="SEND_KEY"}(se||(se={}));class ne{constructor(e){this.wallet=e}static identitySigRequestText(e){return`XMTP : Create Identity\n${j(e)}\n\nFor more info: https://xmtp.org/signatures/`}static signerKey(e,t){return ee(v(b(this.identitySigRequestText(e.bytesToSign()))),t)}async signKey(e){const t=e.toBytes(),s=await this.wallet.signMessage(ne.identitySigRequestText(t)),{bytes:n,recovery:r}=J(s),i=new te({walletEcdsaCompact:{bytes:n,recovery:r}});return new ae({keyBytes:t,signature:i})}}const re=new l(10**9).mul(10**9);class ie{constructor(e){if(!e?.secp256k1Uncompressed)throw new Error("invalid public key");!function(e){if(65!==e.bytes.length)throw new Error(`invalid public key length: ${e.bytes.length}`);if(4!==e.bytes[0])throw new Error(`unrecognized public key prefix: ${e.bytes[0]}`)}(e.secp256k1Uncompressed),this.secp256k1Uncompressed=e.secp256k1Uncompressed,this.createdNs=e.createdNs.toUnsigned()}generated(){return new Date(this.timestamp.toNumber())}isFromLegacyKey(){return this.createdNs.lessThan(re)}get timestamp(){return(this.isFromLegacyKey()?this.createdNs:this.createdNs.div(1e6)).toUnsigned()}verify(e,t){return!!e.ecdsaCompact&&p.verify(e.ecdsaCompact.bytes,t,this.secp256k1Uncompressed.bytes)}async verifyKey(e){if(!e.signature)return!1;const t=await x(e.bytesToSign());return this.verify(e.signature,t)}equals(e){return X(this.secp256k1Uncompressed.bytes,e.secp256k1Uncompressed.bytes)}getEthereumAddress(){return function(e){const t=w(e.slice(1)),s=f(t),n=s.substring(s.length-40);return m(`0x${n}`)}(this.secp256k1Uncompressed.bytes)}toBytes(){return n.UnsignedPublicKey.encode(this).finish()}static fromBytes(e){return new ie(n.UnsignedPublicKey.decode(e))}}class ae extends ie{constructor(e){if(!e.keyBytes)throw new Error("missing key bytes");if(super(n.UnsignedPublicKey.decode(e.keyBytes)),this.keyBytes=e.keyBytes,!e.signature)throw new Error("missing key signature");this.signature=new te(e.signature)}get unsignedKey(){return new ie({createdNs:this.createdNs,secp256k1Uncompressed:this.secp256k1Uncompressed})}signerKey(){return this.signature.signerKey(this)}async walletSignatureAddress(){if(!this.signature.walletEcdsaCompact)throw new Error("key was not signed by a wallet");const e=await this.signerKey();if(!e)throw new Error("key signature not valid");return e.getEthereumAddress()}equals(e){return this.unsignedKey.equals(e.unsignedKey)&&this.signature.equals(e.signature)}bytesToSign(){return this.keyBytes}toBytes(){return n.SignedPublicKey.encode(this).finish()}static fromBytes(e){return new ae(n.SignedPublicKey.decode(e))}toLegacyKey(){if(!this.isFromLegacyKey())throw new Error("cannot be converted to legacy key");let e=this.signature;return e.walletEcdsaCompact&&(e=new te({ecdsaCompact:e.walletEcdsaCompact})),new oe({timestamp:this.timestamp,secp256k1Uncompressed:this.secp256k1Uncompressed,signature:e})}static fromLegacyKey(e,t){if(!e.signature)throw new Error("key is not signed");let s=e.signature;return t&&(s=new te({walletEcdsaCompact:s.ecdsaCompact})),new ae({keyBytes:e.bytesToSign(),signature:s})}}class oe extends ie{constructor(e){super({createdNs:e.timestamp.mul(1e6),secp256k1Uncompressed:e.secp256k1Uncompressed}),e.signature&&(!e.signature.ecdsaCompact&&e.signature.walletEcdsaCompact?this.signature=new te({ecdsaCompact:{bytes:e.signature.walletEcdsaCompact.bytes,recovery:e.signature.walletEcdsaCompact.recovery}}):this.signature=new te(e.signature))}get timestamp(){return this.createdNs.div(1e6)}bytesToSign(){return n.PublicKey.encode({timestamp:this.timestamp,secp256k1Uncompressed:this.secp256k1Uncompressed}).finish()}async signWithWallet(e){const t=await e.signMessage(ne.identitySigRequestText(this.bytesToSign())),{bytes:s,recovery:n}=J(t);this.signature=new te({ecdsaCompact:{bytes:s,recovery:n}})}walletSignatureAddress(){if(!this.signature)throw new Error("key is not signed");const e=v(b(ne.identitySigRequestText(this.bytesToSign()))),t=this.signature.getPublicKey(e);if(!t)throw new Error("key signature is malformed");return t.getEthereumAddress()}toBytes(){return n.PublicKey.encode(this).finish()}static fromBytes(e){return new oe(n.PublicKey.decode(e))}}class ce{constructor(e){if(!e.identityKey)throw new Error("missing identity key");if(!e.preKey)throw new Error("missing pre-key");this.identityKey=new ae(e.identityKey),this.preKey=new ae(e.preKey)}walletSignatureAddress(){return this.identityKey.walletSignatureAddress()}equals(e){return this.identityKey.equals(e.identityKey)&&this.preKey.equals(e.preKey)}toBytes(){return n.SignedPublicKeyBundle.encode(this).finish()}isFromLegacyBundle(){return this.identityKey.isFromLegacyKey()&&this.preKey.isFromLegacyKey()}toLegacyBundle(){return new de({identityKey:this.identityKey.toLegacyKey(),preKey:this.preKey.toLegacyKey()})}static fromBytes(e){const t=n.SignedPublicKeyBundle.decode(e);return new ce(t)}static fromLegacyBundle(e){return new ce({identityKey:ae.fromLegacyKey(e.identityKey,!0),preKey:ae.fromLegacyKey(e.preKey)})}}class de{constructor(e){if(!e.identityKey)throw new Error("missing identity key");if(!e.preKey)throw new Error("missing pre-key");this.identityKey=new oe(e.identityKey),this.preKey=new oe(e.preKey)}equals(e){return this.identityKey.equals(e.identityKey)&&this.preKey.equals(e.preKey)}walletSignatureAddress(){return this.identityKey.walletSignatureAddress()}toBytes(){return n.PublicKeyBundle.encode(this).finish()}static fromBytes(e){const t=n.PublicKeyBundle.decode(e);return new de(t)}}class he{constructor(e,t){this.messageEnvelope=e,this.onSend=t}async messageID(){if(!this.messageEnvelope.message)throw new Error("no envelope message");return j(await x(this.messageEnvelope.message))}async send(){return this.onSend()}}class ye{constructor(e,t,s,n,r){this.messages=[],this.resolvers=[],this.topics=t,this.client=e,this.callback=this.newMessageCallback(s,n),this.onConnectionLost=r}newMessageCallback(e,t){return async s=>{if(s.message)try{const n=await e(s);if(!n)return;if(t){const e=t(n);e&&this.resubscribeToTopics(e)}const r=this.resolvers.pop();r?r({value:n}):this.messages.unshift(n)}catch(e){console.warn(e)}}}async start(){if(!this.callback)throw new Error("Missing callback for stream");this.subscriptionManager=this.client.apiClient.subscribe({contentTopics:this.topics},(async e=>{this.callback&&await(this?.callback(e))}),this.onConnectionLost)}static async create(e,t,s,n,r){const i=new ye(e,t,s,n,r);return await i.start(),i}[Symbol.asyncIterator](){return this}async return(){return this.subscriptionManager&&await this.subscriptionManager.unsubscribe(),this.callback?(this.callback=void 0,this.resolvers.forEach((e=>e({value:void 0,done:!0}))),{value:void 0,done:!0}):{value:void 0,done:!0}}next(){const e=this.messages.pop();return e?Promise.resolve({value:e}):this.callback?new Promise((e=>this.resolvers.unshift(e))):Promise.resolve({value:void 0,done:!0})}async resubscribeToTopics(e){if(!this.callback||!this.subscriptionManager)throw new Error("Missing callback for stream");if("function"==typeof this.subscriptionManager?.updateContentTopics)return this.subscriptionManager.updateContentTopics(e);await this.subscriptionManager.unsubscribe(),this.topics=e,this.subscriptionManager=this.client.apiClient.subscribe({contentTopics:this.topics},(async e=>{this.callback&&await(this?.callback(e))}),this.onConnectionLost)}}const{b64Decode:ue,b64Encode:le}=r;function pe(e,t){const s=new Uint8Array(e.length+t.length);return s.set(e),s.set(t,e.length),s}function we(e){return l.fromNumber(e.valueOf()).multiply(1e6)}function fe(e){return new Date(e.divide(1e6).toNumber())}const me=e=>e&&we(e).toString(),ge=e=>{if(e)return fe(l.fromString(e))};class ve extends Error{constructor(e,t){super(t),this.code=e}}const be=e=>{if(e.error)throw new ve(e.error.code,e.error.message);if(!e.result)throw new ve(i.ErrorCode.ERROR_CODE_UNSPECIFIED,"No result from Keystore");if("encrypted"in e.result&&!e.result.encrypted)throw new Error("Missing ciphertext");if("decrypted"in e.result&&!e.result.decrypted)throw new Error("Missing decrypted result");return e.result},Ee=(e,t)=>({requests:e.map((e=>{const s=new de({identityKey:e.header.sender?.identityKey,preKey:e.header.sender?.preKey}),n=t.equals(s);return{payload:e.ciphertext,peerKeys:n?new de({identityKey:e.header.recipient?.identityKey,preKey:e.header.recipient?.preKey}):s,headerBytes:e.headerBytes,isSender:n}}))}),Ke=e=>`/xmtp/0/${e}/proto`,Ae=(e,t)=>{const s=[m(e),m(t)];return s.sort(),Ke(`dm-${s.join("-")}`)},ke=e=>Ke(`m-${e}`),Te=e=>Ke(`contact-${m(e)}`),Se=e=>Ke(`intro-${m(e)}`),Ce=e=>Ke(`invite-${m(e)}`),Pe=e=>Ke(`privatestore-${e}`),Be=e=>Ke(`userpreferences-${e}`),Ie=e=>{const t=/^[\x21-\x7F]+$/,s=e.indexOf("0/");if(-1!==s){const n=e.substring(s+2,e.lastIndexOf("/proto"));return t.test(n)}return!1};class Re{constructor(e,t,s){this.conversationVersion="v1",this.context=void 0,this.peerAddress=m(t),this.client=e,this.createdAt=s}get clientAddress(){return this.client.address}async allow(){await this.client.contacts.allow([this.peerAddress])}async deny(){await this.client.contacts.deny([this.peerAddress])}get isAllowed(){return this.client.contacts.isAllowed(this.peerAddress)}get isDenied(){return this.client.contacts.isDenied(this.peerAddress)}get consentState(){return this.client.contacts.consentState(this.peerAddress)}get topic(){return Ae(this.peerAddress,this.client.address)}get ephemeralTopic(){return Ae(this.peerAddress,this.client.address).replace("/xmtp/0/dm-","/xmtp/0/dmE-")}async messages(e){const t=Ae(this.peerAddress,this.client.address),s=await this.client.listEnvelopes(t,this.processEnvelope.bind(this),e);return this.decryptBatch(s,t,!1)}messagesPaginated(e){return this.client.listEnvelopesPaginated(this.topic,this.decodeMessage.bind(this),e)}async decodeMessage(e){if(!e.contentTopic)throw new Error("Missing content topic");const t=await this.processEnvelope(e),s=await this.decryptBatch([t],e.contentTopic,!0);if(!s.length)throw new Error("No results");return s[0]}async prepareMessage(e,t){let s,n=await this.client.getUserContact(this.peerAddress);if(!n)throw new Error(`recipient ${this.peerAddress} is not registered`);n instanceof de||(n=n.toLegacyBundle());const r=t?.ephemeral?this.ephemeralTopic:this.topic;this.client.contacts.addresses.has(this.peerAddress)?s=[r]:(s=[Se(this.peerAddress),Se(this.client.address),r],this.client.contacts.addresses.add(this.peerAddress));const{payload:i}=await this.client.encodeContent(e,t),a=await this.createMessage(i,n,t?.timestamp),o=a.toBytes(),c={contentTopic:r,message:o,timestampNs:me(a.sent)};return new he(c,(async()=>(await this.client.publishEnvelopes(s.map((e=>({contentTopic:e,message:o,timestamp:a.sent})))),Ve.fromV1Message(a,e,t?.contentType||K,i,r,this))))}streamMessages(e){return ye.create(this.client,[this.topic],(async e=>this.decodeMessage(e)),void 0,e)}async processEnvelope({message:e,contentTopic:t}){if(!e||!e.length)throw new Error("empty envelope");const s=await _e.fromBytes(e),{senderAddress:n,recipientAddress:r}=s;if(!n||!r||!t||Ae(n,r)!==this.topic)throw new Error("Headers do not match intended recipient");return s}streamEphemeral(e){return ye.create(this.client,[this.ephemeralTopic],this.decodeMessage.bind(this),void 0,e)}async send(e,t){let s,n=await this.client.getUserContact(this.peerAddress);if(!n)throw new Error(`recipient ${this.peerAddress} is not registered`);n instanceof de||(n=n.toLegacyBundle());const r=t?.ephemeral?this.ephemeralTopic:this.topic;this.client.contacts.addresses.has(this.peerAddress)?s=[r]:(s=[Se(this.peerAddress),Se(this.client.address),r],this.client.contacts.addresses.add(this.peerAddress));const i=t?.contentType||K,{payload:a}=await this.client.encodeContent(e,t),o=await this.createMessage(a,n,t?.timestamp);return await this.client.publishEnvelopes(s.map((e=>({contentTopic:e,message:o.toBytes(),timestamp:o.sent})))),"unknown"===this.consentState&&await this.allow(),Ve.fromV1Message(o,e,i,a,r,this)}async decryptBatch(e,t,s=!1){const n=(await this.client.keystore.decryptV1(Ee(e,this.client.publicKeyBundle))).responses,r=[];for(let i=0;i<n.length;i++){const a=n[i],o=e[i];try{const{decrypted:e}=be(a);r.push(await this.buildDecodedMessage(o,e,t))}catch(e){if(s)throw e;console.warn("Error decoding content",e)}}return r}async buildDecodedMessage(e,t,s){const{content:n,contentType:r,error:i,contentFallback:a}=await this.client.decodeContent(t);return Ve.fromV1Message(e,n,r,t,s,this,i,a)}async createMessage(e,t,s){return s=s||new Date,_e.encode(this.client.keystore,e,this.client.publicKeyBundle,t,s)}}class Ne{constructor(e,t,s,n,r,i){this.conversationVersion="v2",this.topic=t,this.createdAt=n,this.context=r,this.client=e,this.peerAddress=s,this.consentProof=i}get clientAddress(){return this.client.address}async allow(){await this.client.contacts.allow([this.peerAddress])}async deny(){await this.client.contacts.deny([this.peerAddress])}get isAllowed(){return this.client.contacts.isAllowed(this.peerAddress)}get isDenied(){return this.client.contacts.isDenied(this.peerAddress)}get consentState(){return this.client.contacts.consentState(this.peerAddress)}get consentProofPayload(){return this.consentProof}async messages(e){const t=await this.client.listEnvelopes(this.topic,this.processEnvelope.bind(this),e);return this.decryptBatch(t,!1)}messagesPaginated(e){return this.client.listEnvelopesPaginated(this.topic,this.decodeMessage.bind(this),e)}get ephemeralTopic(){return this.topic.replace("/xmtp/0/m","/xmtp/0/mE")}streamEphemeral(e){return ye.create(this.client,[this.ephemeralTopic],this.decodeMessage.bind(this),void 0,e)}streamMessages(e){return ye.create(this.client,[this.topic],this.decodeMessage.bind(this),void 0,e)}async send(e,t){const{payload:s,shouldPush:n}=await this.client.encodeContent(e,t),r=await this.createMessage(s,n,t?.timestamp),i=t?.ephemeral?this.ephemeralTopic:this.topic;await this.client.publishEnvelopes([{contentTopic:i,message:r.toBytes(),timestamp:r.sent}]);const a=t?.contentType||K;return"unknown"===this.consentState&&await this.allow(),Ve.fromV2Message(r,e,a,i,s,this,this.client.address)}async createMessage(e,t,s){const n={topic:this.topic,createdNs:we(s||new Date)},r=a.MessageHeaderV2.encode(n).finish(),i=await x(pe(r,e)),c={payload:e,sender:this.client.signedPublicKeyBundle,signature:await this.client.keystore.signDigest({digest:i,prekeyIndex:0,identityKey:void 0})},d=o.SignedContent.encode(c).finish(),{encrypted:h,senderHmac:y}=await this.encryptMessage(d,r),u={v1:void 0,v2:{headerBytes:r,ciphertext:h,senderHmac:y,shouldPush:t}},l=a.Message.encode(u).finish();return xe.create(u,n,l,y,t)}async decryptBatch(e,t=!1){const s=(await this.client.keystore.decryptV2(this.buildDecryptRequest(e))).responses,n=[];for(let r=0;r<s.length;r++){const i=s[r],a=e[r];try{const{decrypted:e}=be(i);n.push(await this.buildDecodedMessage(a,e))}catch(e){if(t)throw e;console.warn("Error decoding content",e)}}return n}buildDecryptRequest(e){return{requests:e.map((e=>({payload:e.ciphertext,headerBytes:e.headerBytes,contentTopic:this.topic})))}}async encryptMessage(e,t){const{responses:s}=await this.client.keystore.encryptV2({requests:[{payload:e,headerBytes:t,contentTopic:this.topic}]});if(1!==s.length)throw new Error("Invalid response length");const{encrypted:n,senderHmac:r}=be(s[0]);return{encrypted:n,senderHmac:r}}async buildDecodedMessage(e,t){const s=o.SignedContent.decode(t);if(!s.sender?.identityKey||!s.sender?.preKey||!s.signature)throw new Error("incomplete signed content");await async function(e){const t=e.sender?.preKey;if(!t||!t.signature||!t.keyBytes)throw new Error("missing pre-key or pre-key signature");const s=e.sender?.identityKey;if(!s)throw new Error("missing identity key in bundle");if(!await new ae(s).verifyKey(new ae(t)))throw new Error("pre key not signed by identity key")}(s);const n=await x(pe(e.headerBytes,s.payload));if(!new ae(s.sender?.preKey).verify(new te(s.signature),n))throw new Error("invalid signature");const r=await new ce(s.sender).walletSignatureAddress(),{content:i,contentType:a,error:c,contentFallback:d}=await this.client.decodeContent(s.payload);return Ve.fromV2Message(e,i,a,this.topic,s.payload,this,r,c,d)}async prepareMessage(e,t){const{payload:s,shouldPush:n}=await this.client.encodeContent(e,t),r=await this.createMessage(s,n,t?.timestamp),i=r.toBytes(),a=t?.ephemeral?this.ephemeralTopic:this.topic,o={contentTopic:a,message:i,timestampNs:me(r.sent)};return new he(o,(async()=>(await this.client.publishEnvelopes([{contentTopic:a,message:i,timestamp:r.sent}]),Ve.fromV2Message(r,e,t?.contentType||K,a,s,this,this.client.address))))}async processEnvelope(e){if(!e.message||!e.contentTopic)throw new Error("empty envelope");const t=a.Message.decode(e.message);if(!t.v2)throw new Error("unknown message version");const s=a.MessageHeaderV2.decode(t.v2.headerBytes);if(s.topic!==this.topic)throw new Error("topic mismatch");return xe.create(t,s,e.message,t.v2.senderHmac,t.v2.shouldPush)}async decodeMessage(e){if(!e.contentTopic)throw new Error("Missing content topic");const t=await this.processEnvelope(e),s=await this.decryptBatch([t],!0);if(!s.length)throw new Error("No results");return s[0]}}const De=e=>{if(e.v1?.ciphertext)return[e.v1.headerBytes,new N(e.v1.ciphertext)];if(e.v2?.ciphertext)return[e.v2.headerBytes,new N(e.v2.ciphertext)];throw new Error("unknown message version")};class Me{constructor(e,t,s){[this.headerBytes,this.ciphertext]=De(s),this.id=e,this.bytes=t}toBytes(){return this.bytes}}class _e extends Me{constructor(e,t,s,n,r){super(e,t,s),this.conversation=void 0,this.senderAddress=r,this.header=n}static async create(e,t,s){if(!t.sender)throw new Error("missing message sender");const n=new de(t.sender).walletSignatureAddress(),r=j(await x(s));return new _e(r,s,e,t,n)}get sent(){return new Date(this.header.timestamp.toNumber())}get recipientAddress(){if(this.header?.recipient?.identityKey)return new oe(this.header.recipient.identityKey).walletSignatureAddress()}async decrypt(e,t){const s=(await e.decryptV1(Ee([this],t))).responses;if(!s.length)throw new Error("No response from Keystore");const{decrypted:n}=be(s[0]);return n}static fromBytes(e){const t=a.Message.decode(e),[s]=De(t),n=a.MessageHeaderV1.decode(s);if(!n)throw new Error("missing message header");if(!n.sender)throw new Error("missing message sender");if(!n.sender.identityKey)throw new Error("missing message sender identity key");if(!n.sender.preKey)throw new Error("missing message sender pre-key");if(!n.recipient)throw new Error("missing message recipient");if(!n.recipient.identityKey)throw new Error("missing message recipient identity-key");if(!n.recipient.preKey)throw new Error("missing message recipient pre-key");return _e.create(t,n,e)}static async encode(e,t,s,n,r){const i={sender:s,recipient:n,timestamp:l.fromNumber(r.getTime())},o=a.MessageHeaderV1.encode(i).finish(),c=await e.encryptV1({requests:[{recipient:n,headerBytes:o,payload:t}]});if(!c.responses.length)throw new Error("No response from Keystore");const{encrypted:d}=be(c.responses[0]),h={v1:{headerBytes:o,ciphertext:d},v2:void 0},y=a.Message.encode(h).finish();return _e.create(h,i,y)}}class xe extends Me{constructor(e,t,s,n,r,i){super(e,t,s),this.header=n,this.senderHmac=r,this.shouldPush=i}static async create(e,t,s,n,r){const i=j(await x(s));return new xe(i,s,e,t,n,r)}get sent(){return fe(this.header.createdNs)}}class Ve{constructor({id:e,messageVersion:t,senderAddress:s,recipientAddress:n,conversation:r,contentBytes:i,contentType:a,contentTopic:o,content:c,sent:d,error:h,contentFallback:y}){this.id=e,this.messageVersion=t,this.senderAddress=s,this.recipientAddress=n,this.conversation=r,this.contentType=a,this.sent=d,this.error=h,this.content=c,this.contentTopic=o,this.contentBytes=i,this.contentFallback=y}toBytes(){return a.DecodedMessage.encode({...this,conversation:{topic:this.conversation.topic,context:this.conversation.context??void 0,createdNs:we(this.conversation.createdAt),peerAddress:this.conversation.peerAddress,consentProofPayload:this.conversation.consentProof??void 0},sentNs:we(this.sent)}).finish()}static async fromBytes(e,t){const s=a.DecodedMessage.decode(e),n=s.messageVersion;if("v1"!==n&&"v2"!==n)throw new Error("Invalid message version");if(!s.conversation)throw new Error("No conversation reference found");const{content:r,contentType:i,error:o,contentFallback:c}=await t.decodeContent(s.contentBytes);return new Ve({...s,content:r,contentType:i,error:o,messageVersion:n,sent:fe(s.sentNs),conversation:Ue(s.conversation,t,n),contentFallback:c})}static fromV1Message(e,t,s,n,r,i,a,o){const{id:c,senderAddress:d,recipientAddress:h,sent:y}=e;if(!d)throw new Error("Sender address is required");return new Ve({id:c,messageVersion:"v1",senderAddress:d,recipientAddress:h,sent:y,content:t,contentBytes:n,contentType:s,contentTopic:r,conversation:i,error:a,contentFallback:o})}static fromV2Message(e,t,s,n,r,i,a,o,c){const{id:d,sent:h}=e;return new Ve({id:d,messageVersion:"v2",senderAddress:a,sent:h,content:t,contentBytes:r,contentType:s,contentTopic:n,conversation:i,error:o,contentFallback:c})}}function Ue(e,t,s){if("v1"===s)return new Re(t,e.peerAddress,fe(e.createdNs));if("v2"===s)return new Ne(t,e.topic,e.peerAddress,fe(e.createdNs),e.context,e.consentProofPayload);throw new Error(`Unknown conversation version ${s}`)}function qe(e,t){return t.decodeContent(e)}class Oe extends Error{constructor(e){super(`no pre-key matches: ${j(e.secp256k1Uncompressed.bytes)}`)}}class Le{constructor(e){if(this.version=2,!e.identityKey)throw new Error("missing identity key");this.identityKey=new Y(e.identityKey),this.preKeys=(e.preKeys||[]).map((e=>new Y(e)))}static async generate(e){const t=await Y.generate(new ne(e)),s=new Le({identityKey:t,preKeys:[]});return await s.addPreKey(),s}getCurrentPreKey(){return this.preKeys[0]}findPreKey(e){const t=this.preKeys.find((t=>t.matches(e)));if(!t)throw new Oe(e);return t}async addPreKey(){this._publicKeyBundle=void 0;const e=await Y.generate(this.identityKey);this.preKeys.unshift(e)}getPublicKeyBundle(){return this._publicKeyBundle||(this._publicKeyBundle=new ce({identityKey:this.identityKey.publicKey,preKey:this.getCurrentPreKey().publicKey})),this._publicKeyBundle}async sharedSecret(e,t,s){if(!e.identityKey||!e.preKey)throw new Error("invalid peer key bundle");if(!await e.identityKey.verifyKey(e.preKey))throw new Error("peer preKey signature invalid");if(!this.identityKey)throw new Error("missing identity key");let n,r,i;s?(i=this.findPreKey(t),n=i.sharedSecret(e.identityKey),r=this.identityKey.sharedSecret(e.preKey)):(i=this.findPreKey(t),n=this.identityKey.sharedSecret(e.preKey),r=i.sharedSecret(e.identityKey));const a=i.sharedSecret(e.preKey),o=new Uint8Array(n.length+r.length+a.length);return o.set(n,0),o.set(r,n.length),o.set(a,n.length+r.length),o}encode(){return t.PrivateKeyBundle.encode({v1:void 0,v2:this}).finish()}validatePublicKeys(){return!!this.identityKey.validatePublicKey()&&this.preKeys.every((e=>e.validatePublicKey()))}equals(e){if(this.preKeys.length!==e.preKeys.length)return!1;for(let t=0;t<this.preKeys.length;t++)if(!this.preKeys[t].equals(e.preKeys[t]))return!1;return this.identityKey.equals(e.identityKey)}static fromLegacyBundle(e){return new Le({identityKey:Y.fromLegacyKey(e.identityKey,!0),preKeys:e.preKeys.map((e=>Y.fromLegacyKey(e)))})}}class He{constructor(e){if(this.version=1,!e.identityKey)throw new Error("missing identity key");this.identityKey=new W(e.identityKey),this.preKeys=(e.preKeys||[]).map((e=>new W(e)))}static async generate(e){const t=W.generate();e&&await t.publicKey.signWithWallet(e);const s=new He({identityKey:t,preKeys:[]});return await s.addPreKey(),s}getCurrentPreKey(){return this.preKeys[0]}findPreKey(e){const t=this.preKeys.find((t=>t.matches(e)));if(!t)throw new Oe(e);return t}async addPreKey(){this._publicKeyBundle=void 0;const e=W.generate();await this.identityKey.signKey(e.publicKey),this.preKeys.unshift(e)}getPublicKeyBundle(){return this._publicKeyBundle||(this._publicKeyBundle=new de({identityKey:this.identityKey.publicKey,preKey:this.getCurrentPreKey().publicKey})),this._publicKeyBundle}validatePublicKeys(){return!!this.identityKey.validatePublicKey()&&this.preKeys.every((e=>e.validatePublicKey()))}async sharedSecret(e,t,s){if(!e.identityKey||!e.preKey)throw new Error("invalid peer key bundle");if(!await e.identityKey.verifyKey(e.preKey))throw new Error("peer preKey signature invalid");if(!this.identityKey)throw new Error("missing identity key");let n,r,i;s?(i=this.findPreKey(t),n=i.sharedSecret(e.identityKey),r=this.identityKey.sharedSecret(e.preKey)):(i=this.findPreKey(t),n=this.identityKey.sharedSecret(e.preKey),r=i.sharedSecret(e.identityKey));const a=i.sharedSecret(e.preKey),o=new Uint8Array(n.length+r.length+a.length);return o.set(n,0),o.set(r,n.length),o.set(a,n.length+r.length),o}encode(){return t.PrivateKeyBundle.encode({v1:this,v2:void 0}).finish()}}function Fe(e){const s=t.PrivateKeyBundle.decode(e);if(s.v1)return new He(s.v1);if(s.v2)return new Le(s.v2);throw new Error("unknown private key bundle version")}class Ge{constructor({walletAddr:e,createdNs:t}){this.walletAddr=e,this.createdNs=t}static create(e,t){return t=t||new Date,new Ge({walletAddr:e,createdNs:we(t)})}static fromBytes(e){const t=c.AuthData.decode(e);return new Ge(t)}toBytes(){return c.AuthData.encode(this).finish()}}class $e{constructor({identityKey:e,authDataBytes:t,authDataSignature:s}){if(!e)throw new Error("Missing identity key in token");if(!s)throw new Error("Missing authDataSignature in token");this.identityKey=e,this.authDataBytes=t,this.authDataSignature=s}get authData(){return this._authData||(this._authData=Ge.fromBytes(this.authDataBytes)),this._authData}get ageMs(){return(new Date).valueOf()-this.authData.createdNs.div(1e6).toNumber()}toBytes(){return c.Token.encode(this).finish()}static fromBytes(e){return new $e(c.Token.decode(e))}toBase64(){return Buffer.from(this.toBytes()).toString("base64")}}class je{constructor(e){this.keystore=e}async createToken(e){return(e=>e instanceof $e?e:new $e(e))(await this.keystore.createAuthToken({timestampNs:e?we(e):void 0}))}}const Xe=e=>new Promise((t=>setTimeout(t,e))),Je=e=>!!e;async function ze(e,t,s,n,r=Je,i=1){const a="number"==typeof i?i:1;try{return await e(...t)}catch(i){if(!r(i)||a>s)throw i;return await Xe(n),ze(e,t,s,n,r,a+1)}}async function*Ye(e,t){for await(const s of e){const e=await Promise.allSettled(s.map(t)),n=[];for(const t of e)"fulfilled"===t.status?n.push(t.value):console.warn("Failed to process envelope due to reason: ",t.reason);yield n}}class We{constructor(e,t=3590){this.authenticator=e,this.maxAgeMs=1e3*t}async getToken(){return(!this.token||this.token.ageMs>this.maxAgeMs)&&await this.refresh(),this.token.toBase64()}async refresh(){this.token=await this.authenticator.createToken()}}const{MessageApi:Qe,SortDirection:Ze}=d,et={local:"http://localhost:5555",dev:"https://dev.xmtp.network",production:"https://production.xmtp.network"};var tt;!function(e){e[e.OK=0]="OK",e[e.CANCELLED=1]="CANCELLED",e[e.UNKNOWN=2]="UNKNOWN",e[e.INVALID_ARGUMENT=3]="INVALID_ARGUMENT",e[e.DEADLINE_EXCEEDED=4]="DEADLINE_EXCEEDED",e[e.NOT_FOUND=5]="NOT_FOUND",e[e.ALREADY_EXISTS=6]="ALREADY_EXISTS",e[e.PERMISSION_DENIED=7]="PERMISSION_DENIED",e[e.RESOURCE_EXHAUSTED=8]="RESOURCE_EXHAUSTED",e[e.FAILED_PRECONDITION=9]="FAILED_PRECONDITION",e[e.ABORTED=10]="ABORTED",e[e.OUT_OF_RANGE=11]="OUT_OF_RANGE",e[e.UNIMPLEMENTED=12]="UNIMPLEMENTED",e[e.INTERNAL=13]="INTERNAL",e[e.UNAVAILABLE=14]="UNAVAILABLE",e[e.DATA_LOSS=15]="DATA_LOSS",e[e.UNAUTHENTICATED=16]="UNAUTHENTICATED"}(tt||(tt={}));class st extends Error{constructor(e,t){super(e),this.code=t}static fromObject(e){return new st(e.message,e.code)}}const nt=e=>!!e&&!("AbortError"!==e.name&&!e.message.includes("aborted")),rt=e=>!(e=>!(!e||!("code"in e)||16!==e.code))(e),it=e=>e.message&&e.message.length?("string"==typeof e.message&&(e.message=ue(e.message)),e):e;class at{constructor(e,t){this.pathPrefix=e,this.maxRetries=t?.maxRetries||5,this.appVersion=t?.appVersion,this.version="xmtp-js/12.0.0",e===et.dev&&console.info("\nXX    XX MM    MM TTTTTT PPPPPP   DDDDD   EEEEEEE VV     VV \n XX  XX  MMM  MMM   TT   PP   PP  DD  DD  EE      VV     VV \n  XXXX   MM MM MM   TT   PPPPPP   DD   DD EEEEE    VV   VV  \n XX  XX  MM    MM   TT   PP       DD   DD EE        VV VV   \nXX    XX MM    MM   TT   PP       DDDDDD  EEEEEEE    VVV    \n\nConnected to the XMTP 'dev' network. Use 'production' for production messages.\nhttps://github.com/xmtp/xmtp-js#xmtp-production-and-dev-network-environments\n")}async _query(e){try{return await ze(Qe.Query,[e,{pathPrefix:this.pathPrefix,mode:"cors",headers:this.headers()}],this.maxRetries,100)}catch(e){throw st.fromObject(e)}}_batchQuery(e){return ze(Qe.BatchQuery,[e,{pathPrefix:this.pathPrefix,mode:"cors",headers:this.headers()}],this.maxRetries,100)}async _publish(e,t=0){const s=await this.getToken(),n=this.headers();n.set("Authorization",`Bearer ${s}`);try{return await ze(Qe.Publish,[e,{pathPrefix:this.pathPrefix,mode:"cors",headers:n}],this.maxRetries,100,rt)}catch(s){if(rt(s)||t>=1)throw st.fromObject(s);return await(this.authCache?.refresh()),this._publish(e,t+1)}}_subscribe(e,t,s){const n=new AbortController;return(async()=>{for(;;){const r=(new Date).getTime();try{if(await Qe.Subscribe(e,t,{pathPrefix:this.pathPrefix,signal:n.signal,mode:"cors",headers:this.headers()}),n.signal.aborted)return;console.info("Stream connection closed. Resubscribing"),(new Date).getTime()-r<1e3&&await Xe(1e3),s?.()}catch(e){if(nt(e)||n.signal.aborted)return;console.info("Stream connection closed. Resubscribing"),(new Date).getTime()-r<1e3&&await Xe(1e3),s?.()}}})(),{unsubscribe:async()=>{n?.abort()}}}async query(e,{direction:t=Ze.SORT_DIRECTION_ASCENDING,limit:s}){const n=[];for await(const r of this.queryIteratePages(e,{direction:t,pageSize:s&&s<100?s:100}))for(const e of r)if(n.push(e),s&&n.length===s)return n;return n}async*queryIterator(e,t){for await(const s of this.queryIteratePages(e,t))for(const e of s)yield e}async*queryIteratePages({contentTopic:e,startTime:t,endTime:s},{direction:n,pageSize:r=10}){if(!e||!e.length)throw new Error("Must specify content topics");const i=me(t),a=me(s);let o;for(;;){const t={limit:r,direction:n,cursor:o},s=await this._query({contentTopics:[e],startTimeNs:i,endTimeNs:a,pagingInfo:t});if(!s.envelopes?.length)return;if(yield s.envelopes.map(it),!s.pagingInfo?.cursor)return;o=s.pagingInfo?.cursor}}async batchQuery(e){const t=[];for(let s=0;s<e.length;s+=50){const n=e.slice(s,s+50),r=[];for(const e of n)r.push({contentTopics:[e.contentTopic],startTimeNs:me(e.startTime),endTimeNs:me(e.endTime),pagingInfo:{limit:e.pageSize||10,direction:e.direction||Ze.SORT_DIRECTION_ASCENDING}});const i={requests:r};t.push(i)}const s=await Promise.all(t.map((async e=>this._batchQuery(e)))),n=[];for(const e of s){if(!e.responses)throw new Error("BatchQueryResponse missing responses");for(const t of e.responses)t.envelopes?n.push(t.envelopes.map(it)):n.push([])}return n}async publish(e){const t=[];for(const{contentTopic:s,message:n,timestamp:r}of e){if(!s.length)throw new Error("Content topic cannot be empty string");if(!n.length)throw new Error("0 length messages not allowed");const e=r||new Date;t.push({contentTopic:s,timestampNs:me(e),message:Uint8Array.from(n)})}return this._publish({envelopes:t})}subscribe(e,t,s){if(!e.contentTopics.length)throw new Error("Must provide list of contentTopics to subscribe to");return this._subscribe(e,(e=>t(it(e))),s)}getToken(){if(!this.authCache)throw new Error("AuthCache is not set on API Client");return this.authCache.getToken()}setAuthenticator(e,t){this.authCache=new We(e,t)}headers(){const e=new Headers;return e.set("X-Client-Version",this.version),this.appVersion&&e.set("X-App-Version",this.appVersion),e}}class ot{constructor(e,t){this.disableOffset=!1,this.jobType=e,this.mutex=new T,this.keystore=t}get protoJobType(){return function(e){const t={v1:i.JobType.JOB_TYPE_REFRESH_V1,v2:i.JobType.JOB_TYPE_REFRESH_V2,"user-preferences":i.JobType.JOB_TYPE_REFRESH_PPPP}[e];if(!t)throw new Error(`unknown job type: ${e}`);return t}(this.jobType)}async run(e){return this.mutex.runExclusive((async()=>{const t=await this.getLastRunTime(),s=new Date,n=await e(t?this.disableOffset?t:new Date(t.getTime()-1e4):void 0);return await this.setLastRunTime(s),n}))}async resetLastRunTime(){await this.keystore.setRefreshJob({jobType:this.protoJobType,lastRunNs:we(new Date(0))})}async getLastRunTime(){const{lastRunNs:e}=await this.keystore.getRefreshJob(i.GetRefreshJobRequest.fromPartial({jobType:this.protoJobType}));if(!e.equals(l.fromNumber(0)))return fe(e)}async setLastRunTime(e){await this.keystore.setRefreshJob({jobType:this.protoJobType,lastRunNs:we(e)})}}const ct=e=>Boolean(e.recipientAddress&&e.senderAddress);class dt{constructor(e){this.client=e,this.v1JobRunner=new ot("v1",e.keystore),this.v2JobRunner=new ot("v2",e.keystore)}async list(){const[e,t]=await Promise.all([this.listV1Conversations(),this.listV2Conversations()]),s=e.concat(t);return s.sort(((e,t)=>e.createdAt.getTime()-t.createdAt.getTime())),s}async listFromCache(){const[e,t]=await Promise.all([this.getV1ConversationsFromKeystore(),this.getV2ConversationsFromKeystore()]),s=e.concat(t);return s.sort(((e,t)=>e.createdAt.getTime()-t.createdAt.getTime())),s}async listV1Conversations(){return this.v1JobRunner.run((async e=>{const t=await this.getIntroductionPeers({startTime:e,direction:Ze.SORT_DIRECTION_ASCENDING});return await this.client.keystore.saveV1Conversations({conversations:Array.from(t).map((([e,t])=>({peerAddress:e,createdNs:we(t),topic:Ae(e,this.client.address),context:void 0,consentProofPayload:void 0}))).filter((e=>Ie(e.topic)))}),(await this.client.keystore.getV1Conversations()).conversations.map(this.conversationReferenceToV1.bind(this))}))}async listV2Conversations(){return this.v2JobRunner.run((async e=>{const t=await this.getV2ConversationsFromKeystore(),s=await this.updateV2Conversations(e),n=new Set(t.map((e=>e.topic)));for(const e of s)n.has(e.topic)||(t.push(e),n.add(e.topic));return t.sort(((e,t)=>e.createdAt.getTime()-t.createdAt.getTime())),t}))}async getV2ConversationsFromKeystore(){return(await this.client.keystore.getV2Conversations()).conversations.map(this.conversationReferenceToV2.bind(this))}async getV1ConversationsFromKeystore(){return(await this.client.keystore.getV1Conversations()).conversations.map(this.conversationReferenceToV1.bind(this))}async updateV2Conversations(e){const t=await this.client.listInvitations({startTime:e,direction:Ze.SORT_DIRECTION_ASCENDING});return this.decodeInvites(t)}async decodeInvites(e,t=!1){const{responses:s}=await this.client.keystore.saveInvites({requests:e.map((e=>({payload:e.message,timestampNs:l.fromString(e.timestampNs),contentTopic:e.contentTopic}))).filter((e=>Ie(e.contentTopic)))}),n=[];for(const e of s)try{n.push(this.saveInviteResponseToConversation(e))}catch(e){if(console.warn("Error saving invite response to conversation: ",e),t)throw e}return n}saveInviteResponseToConversation({result:e,error:t}){if(t||!e||!e.conversation)throw new Error(`Error from keystore: ${t?.code} ${t?.message}}`);return this.conversationReferenceToV2(e.conversation)}conversationReferenceToV2(e){return new Ne(this.client,e.topic,e.peerAddress,fe(e.createdNs),e.context,e.consentProofPayload)}conversationReferenceToV1(e){return new Re(this.client,e.peerAddress,fe(e.createdNs))}async stream(e){const t=new Set,s=Se(this.client.address),n=Ce(this.client.address),r=[s,n];return ye.create(this.client,r,(async e=>{if(e.contentTopic===s){if(!e.message)throw new Error("empty envelope");const s=await _e.fromBytes(e.message),n=this.getPeerAddress(s);if(!(e=>!t.has(e)&&(t.add(e),!0))(n))return;return await s.decrypt(this.client.keystore,this.client.publicKeyBundle),new Re(this.client,n,s.sent)}if(e.contentTopic===n){const t=await this.decodeInvites([e],!0);if(t.length)return t[0]}throw new Error("unrecognized invite topic")}).bind(this),void 0,e)}async streamAllMessages(e){const t=Se(this.client.address),s=Ce(this.client.address),n=new Set([t,s]),r=new Map;for(const e of await this.list())n.add(e.topic),r.set(e.topic,e);const i=(e,t)=>!n.has(e)&&(r.set(e,t),n.add(e),!0),a=await ye.create(this.client,Array.from(n.values()),(async e=>{const n=e.contentTopic;if(!n||!e.message)return null;if(n===t){const t=await _e.fromBytes(e.message);if(!ct(t))return null;const s=this.getPeerAddress(t);return new Re(this.client,s,t.sent).decodeMessage(e)}if(n===s){return(await this.decodeInvites([e],!0))[0]}const i=r.get(n);if(i instanceof Re)return i.decodeMessage(e);if(i instanceof Ne)return i.decodeMessage(e);throw console.log("Unknown topic"),new Error("Unknown topic")}),(e=>{if(e instanceof Ve&&e.contentTopic===t){const t=new Re(this.client,e.recipientAddress?.toLowerCase()===this.client.address.toLowerCase()?e.senderAddress:e.recipientAddress,e.sent);return i(t.topic,t)?Array.from(n.values()):void 0}if(e instanceof Ne){return i(e.topic,e)?Array.from(n.values()):void 0}}),e),o=async function*(){for await(const e of a)if(e instanceof Ve&&(yield e),e instanceof Ne)for(const t of await e.messages())yield t}();return o.return=async()=>(await(a?.return()),{value:void 0,done:!0}),o}async getIntroductionPeers(e){const t=Se(this.client.address),s=await this.client.listEnvelopes(t,(e=>{if(!e.message)throw new Error("empty envelope");return _e.fromBytes(e.message)}),e),n=new Map;for(const e of s){if(!ct(e))continue;const t=this.getPeerAddress(e);if(t){const s=n.get(t);if(!s||s>e.sent)try{await e.decrypt(this.client.keystore,this.client.publicKeyBundle),n.set(t,e.sent)}catch(e){continue}}}return n}async newConversation(e,t,s){const n=s=>{return s.peerAddress.toLowerCase()===e.toLowerCase()&&(n=t,r=s.context??void 0,n?.conversationId===r?.conversationId);var n,r},r=(await this.getV2ConversationsFromKeystore()).find(n);if(r)return r;let i=await this.client.getUserContact(e);if(!i)throw new Error(`Recipient ${e} is not on the XMTP network`);if(e.toLowerCase()===this.client.address.toLowerCase())throw new Error("self messaging not supported");if(i instanceof de&&!t?.conversationId)return new Re(this.client,e,new Date);if(!t?.conversationId){const t=(await this.listV1Conversations()).find((t=>t.peerAddress.toLowerCase()===e.toLowerCase()));if(t){if(!this.client.signedPublicKeyBundle.isFromLegacyBundle())throw new Error("cannot resume pre-existing V1 conversation; client keys not compatible");if(!(i instanceof de||i.isFromLegacyBundle()))throw new Error("cannot resume pre-existing V1 conversation; peer keys not compatible");return t}}return i instanceof de&&(i=ce.fromLegacyBundle(i)),this.v2JobRunner.run((async e=>{const r=(await this.updateV2Conversations(e)).find(n);return r||this.createV2Convo(i,t,s)}))}async createV2Convo(e,t,s){const n=new Date,{payload:r,conversation:i}=await this.client.keystore.createInvite({recipient:e,context:t,createdNs:we(n),consentProof:s});if(!r||!i)throw new Error("Required field not returned from Keystore");const a=await e.walletSignatureAddress();return await this.client.publishEnvelopes([{contentTopic:Ce(a),message:r,timestamp:n},{contentTopic:Ce(this.client.address),message:r,timestamp:n}]),await this.client.contacts.allow([a]),this.conversationReferenceToV2(i)}getPeerAddress(e){return e.recipientAddress?.toLowerCase()===this.client.address.toLowerCase()?e.senderAddress:e.recipientAddress}}class ht{constructor(e){this.storage=e}static create(){if("undefined"==typeof localStorage)throw new Error("Missing LocalStorage. Use ephemeralPersistence instead");return new ht(localStorage)}async getItem(e){const t=this.storage.getItem(e);return null===t?null:Uint8Array.from(Buffer.from(t,"binary"))}async setItem(e,t){this.storage.setItem(e,Buffer.from(t).toString("binary"))}}class yt{constructor(){this.store=new Map}get length(){return this.store.size}clear(){this.store=new Map}getItem(e){return this.validateString(e),this.store.has(e)?String(this.store.get(e)):null}key(e){if(void 0===e)throw new TypeError("Failed to execute 'key' on 'Storage': 1 argument required, but only 0 present.");const t=[...this.store.keys()];return e>=t.length?null:t[e]}removeItem(e){this.validateString(e),this.store.delete(e)}setItem(e,t){this.validateString(e),this.validateString(t),this.store.set(String(e),String(t))}validateString(e){if("string"!=typeof e)throw new TypeError("Key must be a string")}}class ut extends ht{static create(){return new ht(new yt)}}class lt extends Error{}class pt{constructor(e){if(!e.publicKey.signature)throw new Error("Provided public key is not signed");this.identityKey=e}async createToken(e){const t=Ge.create(this.identityKey.publicKey.walletSignatureAddress(),e||new Date).toBytes(),r=f(t),i=await this.identityKey.sign(v(r));return new $e(c.Token.fromPartial({identityKey:n.PublicKey.fromPartial(this.identityKey.publicKey),authDataBytes:t,authDataSignature:s.Signature.fromPartial(i)}))}}const wt=new(0,S.ec)("secp256k1"),ft=D.subtle,mt=Buffer.from("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141","hex"),gt=Buffer.alloc(32,0);function vt(e,t){if(!e)throw new Error(t||"Assertion failed")}function bt(e){return t=e,!(!Buffer.isBuffer(t)||32!==t.length)&&(e.compare(gt)>0&&e.compare(mt)<0);var t}function Et(e){const t=new Uint8Array(e);return D.getRandomValues(t),Buffer.from(t)}async function Kt(e){const t=await ft.digest("SHA-512",e);return Buffer.from(t)}function At(e){return function(t,s,n){return new Promise((function(r){return ft.importKey("raw",s,{name:"AES-CBC"},!1,[e]).then((function(s){const r={name:"AES-CBC",iv:t};return ft[e](r,s,n)})).then((function(e){r(Buffer.from(new Uint8Array(e)))}))}))}}const kt=At("encrypt"),Tt=At("decrypt");async function St(e,t){const s=await ft.importKey("raw",e,{name:"HMAC",hash:{name:"SHA-256"}},!1,["sign"]);return Buffer.from(await ft.sign({name:"HMAC",hash:"SHA-256"},s,t))}function Ct(e){return vt(32===e.length,"Bad private key"),vt(bt(e),"Bad private key"),Buffer.from(wt.keyFromPrivate(e).getPublic("array"))}function Pt(e,t){return new Promise((function(s){vt(Buffer.isBuffer(e),"Bad private key"),vt(Buffer.isBuffer(t),"Bad public key"),vt(32===e.length,"Bad private key"),vt(bt(e),"Bad private key"),vt(65===t.length||33===t.length,"Bad public key"),65===t.length&&vt(4===t[0],"Bad public key"),33===t.length&&vt(2===t[0]||3===t[0],"Bad public key");const n=wt.keyFromPrivate(e),r=wt.keyFromPublic(t),i=n.derive(r.getPublic());s(Buffer.from(i.toArray()))}))}async function Bt(e,t){const s=await Pt(e,t.ephemeralPublicKey),n=await Kt(s),r=n.slice(0,32),i=n.slice(32),a=Buffer.concat([t.iv,t.ephemeralPublicKey,t.ciphertext]);return vt(await async function(e,t,s){return function(e,t){if(e.length!==t.length)return!1;let s=0;for(let n=0;n<e.length;n++)s|=e[n]^t[n];return 0===s}(await St(e,t),s)}(i,a,t.mac),"Bad mac"),Tt(t.iv,r,t.ciphertext)}async function It(e,t){await C();const s=e.publicKey.secp256k1Uncompressed.bytes,n=e.secp256k1.bytes;return P(s,n,t)}async function Rt(e,t){await C();const s=e.publicKey.secp256k1Uncompressed.bytes,n=e.secp256k1.bytes;return B(s,n,t)}class Nt{constructor({topic:e,context:t,aes256GcmHkdfSha256:s,consentProof:n}){if(!e||!e.length)throw new Error("Missing topic");if(!s||!s.keyMaterial||!s.keyMaterial.length)throw new Error("Missing key material");this.topic=e,this.context=t,this.aes256GcmHkdfSha256=s,this.consentProof=n}static createRandom(e,t){const s=ke(Buffer.from(D.getRandomValues(new Uint8Array(32))).toString("base64").replace(/=*$/g,"").replace(/\//g,"-")),n=D.getRandomValues(new Uint8Array(32));return new Nt({topic:s,aes256GcmHkdfSha256:{keyMaterial:n},context:e,consentProof:t})}toBytes(){return h.InvitationV1.encode(this).finish()}static fromBytes(e){return new Nt(h.InvitationV1.decode(e))}}class Dt{constructor({sender:e,recipient:t,createdNs:s}){if(!e)throw new Error("Missing sender");if(!t)throw new Error("Missing recipient");this.sender=new ce(e),this.recipient=new ce(t),this.createdNs=s}toBytes(){return h.SealedInvitationHeaderV1.encode(this).finish()}static fromBytes(e){return new Dt(h.SealedInvitationHeaderV1.decode(e))}}class Mt{constructor({headerBytes:e,ciphertext:t}){if(!e||!e.length)throw new Error("Missing header bytes");if(!t)throw new Error("Missing ciphertext");this.headerBytes=e,this.ciphertext=new N(t)}get header(){return this._header||(this._header=Dt.fromBytes(this.headerBytes)),this._header}async getInvitation(e){if(this._invitation)return this._invitation;const t=this.header;let s;s=e.identityKey.matches(this.header.sender.identityKey)?await e.sharedSecret(t.recipient,t.sender.preKey,!1):await e.sharedSecret(t.sender,t.recipient.preKey,!0);const n=await U(this.ciphertext,s,this.headerBytes);return this._invitation=Nt.fromBytes(n),this._invitation}toBytes(){return h.SealedInvitationV1.encode(this).finish()}static fromBytes(e){return new Mt(h.SealedInvitationV1.decode(e))}}class _t{constructor({v1:e}){if(!e)throw new Error("Missing v1 or v2 invitation");this.v1=new Mt(e)}toBytes(){return h.SealedInvitation.encode(this).finish()}static fromBytes(e){return new _t(h.SealedInvitation.decode(e))}static async fromEnvelope(e){if(!e.message||!e.timestampNs)throw new Error("invalid invitation envelope");const t=_t.fromBytes(e.message),s=l.fromString(e.timestampNs),n=t.v1?.header.createdNs;if(!n||!n.equals(s))throw new Error("envelope and header timestamp mistmatch");return t}static async createV1({sender:e,recipient:t,created:s,invitation:n}){const r=new Dt({sender:e.getPublicKeyBundle(),recipient:t,createdNs:we(s)}).toBytes(),i=await e.sharedSecret(t,e.getCurrentPreKey().publicKey,!1),a=n.toBytes(),o=await V(a,i,r);return new _t({v1:{headerBytes:r,ciphertext:o}})}}const xt=(e,t)=>e instanceof ve?e:new ve(t,e.message),Vt=(e,t,s)=>Promise.all(e.map((async e=>{try{return{result:await t(e)}}catch(e){return{error:xt(e,s)}}}))),Ut=e=>e instanceof de?e:new de(e),qt=(e,t,s)=>{for(const s of t)if(!e[s])throw new ve(i.ErrorCode.ERROR_CODE_INVALID_INPUT,`Missing field ${String(s)}`);for(const t of s){const s=e[t];if(!s||!s?.length)throw new ve(i.ErrorCode.ERROR_CODE_INVALID_INPUT,`Missing field ${String(t)}`)}return!0},Ot=e=>{if(!e?.aes256GcmHkdfSha256?.keyMaterial)throw new ve(i.ErrorCode.ERROR_CODE_INVALID_INPUT,"Missing key material");return e.aes256GcmHkdfSha256.keyMaterial},Lt=({invitation:e,createdNs:t,peerAddress:s})=>({context:e.context,topic:e.topic,peerAddress:s,createdNs:t,consentProofPayload:e.consentProof});class Ht{constructor(e,t,s=new Map){this.persistenceKey=t,this.persistence=e,this.revision=0,this.mutex=new T,this.topicMap=s}get revisionKey(){return this.persistenceKey+"/revision"}static async create(e){const t=new Ht(e,"invitations/v1");return await t.refresh(),t}validate(e){return!!e.topic&&e.topic.length>0&&!!e.invitation}async refresh(){const e=await this.getRevision();if(e>this.revision)for(const[e,t]of await this.loadFromPersistence())this.topicMap.set(e,t);this.revision=e}async getRevision(){const e=await this.persistence.getItem(this.revisionKey);return e?function(e){const t=e.buffer;return new DataView(t).getInt32(0,!0)}(e):0}async setRevision(e){await this.persistence.setItem(this.revisionKey,function(e){const t=new ArrayBuffer(4);return new DataView(t).setInt32(0,e,!0),new Uint8Array(t)}(e))}async loadFromPersistence(){const e=await this.persistence.getItem(this.persistenceKey);return e?(e=>{const t=new Map;for(const[s,n]of Object.entries(e.topics))t.set(s,n);return t})(i.TopicMap.decode(e)):new Map}async store(){await this.persistence.setItem(this.persistenceKey,this.toBytes()),this.revision++,await this.setRevision(this.revision)}async add(e){await this.mutex.runExclusive((async()=>{await this.refresh();let t=!1;for(const s of e){if(!this.validate(s)){console.warn("Invalid topic data",s.topic);continue}const{topic:e,...n}=s;this.topicMap.has(e)||(this.topicMap.set(e,n),t=!0)}t&&await this.store()}))}get topics(){return[...this.topicMap.values()]}lookup(e){return this.topicMap.get(e)}toBytes(){return i.TopicMap.encode({topics:Object.fromEntries(this.topicMap)}).finish()}}class Ft extends Ht{static async create(e){const t=new Ft(e,"conversation-v1/v1");return await t.refresh(),t}validate(e){return!!(e.topic&&e.topic.length&&e.peerAddress?.length>0)}}const Gt=async(e,t,s,n)=>V(s,await e.sharedSecret(t,e.getCurrentPreKey().publicKey,!1),n),{ErrorCode:$t}=i,jt=(new TextEncoder).encode("__XMTP__INVITATION__SALT__XMTP__");class Xt{constructor(e,t,s,n){this.v1Keys=e,this.v2Keys=Le.fromLegacyBundle(e),this.v1Store=t,this.v2Store=s,this.authenticator=new pt(e.identityKey),this.jobStatePersistence=n}static async create(e,t){return new Xt(e,await Ft.create(t),await Ht.create(t),t)}get walletAddress(){return this.v1Keys.identityKey.publicKey.walletSignatureAddress()}async decryptV1(e){const t=await Vt(e.requests,(async e=>{qt(e,["payload","peerKeys"],["headerBytes"]);const{payload:t,peerKeys:s,headerBytes:n,isSender:r}=e,i=await(async(e,t,s,n,r)=>U(s,await e.sharedSecret(t,e.getCurrentPreKey().publicKey,!r),n))(this.v1Keys,Ut(s),t,n,r);return{decrypted:i}}),i.ErrorCode.ERROR_CODE_UNSPECIFIED);return i.DecryptResponse.fromPartial({responses:t})}async decryptV2(e){const t=await Vt(e.requests,(async e=>{qt(e,["payload"],["headerBytes"]);const{payload:t,headerBytes:s,contentTopic:n}=e,r=this.v2Store.lookup(n);if(!r)throw new ve(i.ErrorCode.ERROR_CODE_NO_MATCHING_PREKEY,"no topic key");const a=await((e,t,s)=>U(e,t,s))(t,Ot(r.invitation),s);return{decrypted:a}}),$t.ERROR_CODE_UNSPECIFIED);return i.DecryptResponse.fromPartial({responses:t})}async encryptV1(e){const t=await Vt(e.requests,(async e=>{qt(e,["payload","recipient"],["headerBytes"]);const{recipient:t,payload:s,headerBytes:n}=e;return{encrypted:await Gt(this.v1Keys,Ut(t),s,n)}}),$t.ERROR_CODE_UNSPECIFIED);return i.EncryptResponse.fromPartial({responses:t})}async createAuthToken({timestampNs:e}){return this.authenticator.createToken(e?fe(e):void 0)}async selfEncrypt(e){const t=await Vt(e.requests,(async e=>{const{payload:t}=e;if(!t)throw new ve($t.ERROR_CODE_INVALID_INPUT,"Missing field payload");return{encrypted:await It(this.v1Keys.identityKey,t)}}),$t.ERROR_CODE_INVALID_INPUT);return i.SelfEncryptResponse.fromPartial({responses:t})}async selfDecrypt(e){const t=await Vt(e.requests,(async e=>{const{payload:t}=e;if(!t)throw new ve($t.ERROR_CODE_INVALID_INPUT,"Missing field payload");return{decrypted:await Rt(this.v1Keys.identityKey,t)}}),$t.ERROR_CODE_INVALID_INPUT);return i.DecryptResponse.fromPartial({responses:t})}async getPrivatePreferencesTopicIdentifier(){const e=await async function(e){await C();const t=e.secp256k1.bytes;return I(t)}(this.v1Keys.identityKey);return i.GetPrivatePreferencesTopicIdentifierResponse.fromPartial({identifier:e})}async encryptV2(e){const t=await Vt(e.requests,(async e=>{qt(e,["payload"],["headerBytes"]);const{payload:t,headerBytes:s,contentTopic:n}=e,r=this.v2Store.lookup(n);if(!r)throw new ve($t.ERROR_CODE_NO_MATCHING_PREKEY,"no topic key");const i=Ot(r.invitation),a=await((e,t,s)=>V(e,t,s))(t,i,s),o=`${Math.floor(Date.now()/1e3/60/60/24/30)}-${await this.getAccountAddress()}`;return{encrypted:a,senderHmac:await H(i,(new TextEncoder).encode(o),s)}}),$t.ERROR_CODE_INVALID_INPUT);return i.EncryptResponse.fromPartial({responses:t})}async saveInvites(e){const t=[],s=await Vt(e.requests,(async({payload:e,timestampNs:s})=>{const n=_t.fromBytes(e);if(n.v1){if(!n.v1.header.createdNs.equals(s))throw new Error("envelope and header timestamp mismatch");const e=n.v1.header.sender.equals(this.v2Keys.getPublicKeyBundle()),r=await n.v1.getInvitation(this.v2Keys),i={invitation:r,createdNs:n.v1.header.createdNs,peerAddress:e?await n.v1.header.recipient.walletSignatureAddress():await n.v1.header.sender.walletSignatureAddress()};return t.push({...i,topic:r.topic}),{conversation:Lt(i)}}}),$t.ERROR_CODE_INVALID_INPUT);return await this.v2Store.add(t),i.SaveInvitesResponse.fromPartial({responses:s})}async createInvite(e){try{qt(e,["recipient"],[]);const s=fe(e.createdNs),n=(t=e.recipient)instanceof ce?t:new ce(t),r=await this.getAccountAddress(),a=await n.walletSignatureAddress(),o=await this.v2Keys.sharedSecret(n,this.v2Keys.getCurrentPreKey().publicKey,r<a),c=[r,a].sort(),d=(e.context?.conversationId||"")+c.join(),h=(new TextEncoder).encode(d),y=j(await St(Buffer.from(o),Buffer.from(h))),u=["0",...c].join("|"),l=(new TextEncoder).encode(u),p=await async function(e,t){const s=await D.subtle.importKey("raw",e,"HKDF",!1,["deriveKey"]);return D.subtle.deriveKey({name:"HKDF",hash:"SHA-256",salt:jt,info:t},s,{name:"AES-GCM",length:256},!0,["encrypt","decrypt"])}(o,l),w=new Uint8Array(await D.subtle.exportKey("raw",p)),f=new Nt({topic:ke(y),aes256GcmHkdfSha256:{keyMaterial:w},context:e.context,consentProof:e.consentProof}),m=await _t.createV1({sender:this.v2Keys,recipient:n,created:s,invitation:f}),g={invitation:f,topic:f.topic,createdNs:e.createdNs,peerAddress:await n.walletSignatureAddress()};return await this.v2Store.add([g]),i.CreateInviteResponse.fromPartial({conversation:Lt(g),payload:m.toBytes()})}catch(e){throw xt(e,$t.ERROR_CODE_INVALID_INPUT)}var t}async signDigest(e){qt(e,["digest"],[]);const{digest:t,identityKey:s,prekeyIndex:n}=e;let r;if(s)r=this.v1Keys.identityKey;else{if(void 0===n||!Number.isInteger(n))throw new ve($t.ERROR_CODE_INVALID_INPUT,"must specifify identityKey or prekeyIndex");if(r=this.v1Keys.preKeys[n],!r)throw new ve($t.ERROR_CODE_NO_MATCHING_PREKEY,"no prekey found")}return r.sign(t)}async saveV1Conversations({conversations:e}){return await this.v1Store.add(e.map((e=>({topic:Ae(e.peerAddress,this.walletAddress),peerAddress:e.peerAddress,createdNs:e.createdNs,invitation:void 0})))),{}}async getV1Conversations(){return{conversations:this.v1Store.topics.map(this.topicDataToV1ConversationReference.bind(this))}}async getV2Conversations(){const e=this.v2Store.topics.map((e=>Lt(e)));return e.sort(((e,t)=>e.createdNs.div(1e6).sub(t.createdNs.div(1e6)).toNumber())),i.GetConversationsResponse.fromPartial({conversations:e})}async getPublicKeyBundle(){return this.v1Keys.getPublicKeyBundle()}async getPrivateKeyBundle(){return this.v1Keys}async getAccountAddress(){return this.accountAddress||(this.accountAddress=await this.v2Keys.getPublicKeyBundle().walletSignatureAddress()),this.accountAddress}async getRefreshJob({jobType:e}){if(e===i.JobType.JOB_TYPE_UNSPECIFIED)throw new ve($t.ERROR_CODE_INVALID_INPUT,"invalid job type");const t=await this.getLastRunTime(e);return i.GetRefreshJobResponse.fromPartial({lastRunNs:t||l.fromNumber(0)})}async setRefreshJob({jobType:e,lastRunNs:t}){const s=await this.buildJobStorageKey(e);return await this.jobStatePersistence.setItem(s,Uint8Array.from(t.toBytes())),{}}topicDataToV1ConversationReference(e){return{peerAddress:e.peerAddress,createdNs:e.createdNs,topic:Ae(e.peerAddress,this.walletAddress),context:void 0,consentProofPayload:void 0}}buildJobStorageKey(e){return`refreshJob/${e.toString()}`}async getLastRunTime(e){const t=await this.jobStatePersistence.getItem(this.buildJobStorageKey(e));if(t&&t.length)return l.fromBytes([...t])}lookupTopic(e){return this.v2Store.lookup(e)}async getV2ConversationHmacKeys(e){const t=Math.floor(Date.now()/1e3/60/60/24/30),s={};let n=this.v2Store.topics;return e?.topics&&(n=n.filter((t=>void 0!==t.invitation&&e.topics.includes(t.invitation.topic)))),await Promise.all(n.map((async e=>{if(e.invitation?.topic){const n=Ot(e.invitation),r=await Promise.all([t-1,t,t+1].map((async e=>{const t=`${e}-${await this.getAccountAddress()}`,s=await L(n,(new TextEncoder).encode(t));return{thirtyDayPeriodsSinceEpoch:e,hmacKey:await G(s)}})));s[e.invitation.topic]={values:r}}}))),{hmacKeys:s}}}class Jt{constructor(e){this.apiClient=e}async getItem(e){for await(const t of this.apiClient.queryIterator({contentTopic:this.buildTopic(e)},{pageSize:1,direction:d.SortDirection.SORT_DIRECTION_DESCENDING}))if(t.message)try{return Uint8Array.from(t.message)}catch(e){console.log(e)}return null}async setItem(e,t){const s=Uint8Array.from(t);await this.apiClient.publish([{contentTopic:this.buildTopic(e),message:s}])}setAuthenticator(e){this.apiClient.setAuthenticator(e)}buildTopic(e){return Pe(e)}}class zt{constructor({eciesBytes:t,signature:s}){if(!t||!t.length)throw new Error("eciesBytes is empty");if(!s)throw new Error("signature is undefined");this.eciesBytes=t,this.signature=new te(s),this.ciphertext=e.SignedEciesCiphertext_Ecies.decode(t)}toBytes(){return e.SignedEciesCiphertext.encode(this).finish()}async verify(e){return e.verify(this.signature,await x(this.eciesBytes))}static fromBytes(t){const s=e.SignedEciesCiphertext.decode(t);return new zt(s)}static async create(t,s){(e=>{if(16!==e.iv.length)throw new Error("Invalid iv length");if(65!==e.ephemeralPublicKey.length)throw new Error("Invalid ephemPublicKey length");if(e.ciphertext.length<1||e.ciphertext.length%16!=0)throw new Error("Invalid ciphertext length");if(32!==e.mac.length)throw new Error("Invalid mac length")})(t);const n=e.SignedEciesCiphertext_Ecies.encode(t).finish(),r=await s.sign(await x(n));return new zt({eciesBytes:n,signature:r})}}class Yt{constructor(e,t){this.persistence=e,this.privateKey=t,this.privateKeyBytes=Buffer.from(t.secp256k1.bytes),this.publicKey=Ct(this.privateKeyBytes)}async getItem(e){const t=await this.persistence.getItem(e);return t?this.decrypt(t):null}async setItem(e,t){const s=await this.encrypt(t);await this.persistence.setItem(e,s)}async encrypt(e){const t=await async function(e,t,s){s=s||{};const n=s?.iv||Et(16);let r=s?.ephemPrivateKey||Et(32);for(;!bt(r);){if(s?.ephemPrivateKey)throw new Error("ephemPrivateKey is not valid");r=Et(32)}const i=Ct(r),a=await Kt(await Pt(r,e)),o=a.slice(0,32),c=a.slice(32),d=await kt(n,o,t),h=Buffer.concat([n,i,d]);return{iv:n,ephemeralPublicKey:i,ciphertext:d,mac:await St(c,h)}}(this.publicKey,Buffer.from(e));return this.serializeEcies(t)}async decrypt(e){const t=await this.deserializeEcies(e),s=await Bt(this.privateKeyBytes,t);return Uint8Array.from(s)}async serializeEcies(e){return(await zt.create(e,this.privateKey)).toBytes()}async deserializeEcies(e){const t=zt.fromBytes(e);if(!await t.verify(this.privateKey.publicKey))throw new Error("signature validation failed");const s=t.ciphertext;return{ciphertext:Buffer.from(s.ciphertext),mac:Buffer.from(s.mac),iv:Buffer.from(s.iv),ephemeralPublicKey:Buffer.from(s.ephemeralPublicKey)}}}class Wt{constructor(e,t){this.prefix=e,this.persistence=t}getItem(e){return this.persistence.getItem(this.buildKey(e))}setItem(e,t){return this.persistence.setItem(this.buildKey(e),t)}buildKey(e){return this.prefix+e}}const Qt=async(e,t)=>{if(!e.persistConversations)return ut.create();const s=await t.identityKey.publicKey.walletSignatureAddress(),n=`xmtp/${e.env}/${s}/`;const r=e.basePersistence,i=!e.disablePersistenceEncryption;return new Wt(n,i?new Yt(r,t.identityKey):r)},Zt="key_bundle";class es{constructor(e,t,s){this.signer=e,this.persistence=t,this.preEnableIdentityCallback=s}async getStorageAddress(e){let t=await this.signer.getAddress();return t=m(t),`${t}/${e}`}async loadPrivateKeyBundle(){const e=await this.persistence.getItem(await this.getStorageAddress(Zt));if(!e)return null;const[t,s]=await this.fromEncryptedBytes(this.signer,Uint8Array.from(e));return s&&await this.storePrivateKeyBundle(t),t}async storePrivateKeyBundle(e){const t=await this.getStorageAddress(Zt),s=await this.toEncryptedBytes(e,this.signer);"function"==typeof this.persistence.setAuthenticator&&this.persistence.setAuthenticator(new pt(e.identityKey)),await this.persistence.setItem(t,s)}async toEncryptedBytes(e,s){const n=e.encode(),r=D.getRandomValues(new Uint8Array(32)),i=ss(r),a=await s.getAddress();this.preEnableIdentityCallback&&await this.preEnableIdentityCallback();const o=await s.signMessage(i);if(!E({address:a,message:i,signature:o}))throw new Error("invalid signature");const c=v(o),d=await V(n,c);return t.EncryptedPrivateKeyBundle.encode({v1:{walletPreKey:r,ciphertext:d}}).finish()}async fromEncryptedBytes(e,s){const[n,r]=function(e){try{const s=t.EncryptedPrivateKeyBundle.decode(e);if(s.v1)return[s.v1,!1]}catch(s){return[t.EncryptedPrivateKeyBundleV1.decode(e),!0]}throw new Error("unrecognized encrypted private key bundle version")}(s);if(!n.walletPreKey)throw new Error("missing wallet pre-key");if(!n.ciphertext?.aes256GcmHkdfSha256)throw new Error("missing bundle ciphertext");this.preEnableIdentityCallback&&await this.preEnableIdentityCallback();const i=v(await e.signMessage(ss(n.walletPreKey)));try{const e=new N(n.ciphertext),t=await U(e,i),[s,a]=ts(t);return[s,r||a]}catch(e){if(65!==i.length)throw new Error("Expected 65 bytes before trying a different recovery byte");const t=i[i.length-1];let s=i.slice(0,i.length-1);s=t<27?new Uint8Array([...s,t+27]):new Uint8Array([...s,t-27]);const a=new N(n.ciphertext),o=await U(a,s),[c,d]=ts(o);return[c,r||d]}}}function ts(e){try{const t=Fe(e);if(t instanceof Le)throw new Error("V2 bundles not supported yet");return[t,!1]}catch(s){const n=t.PrivateKeyBundleV1.decode(e);return[new He(n),!0]}}function ss(e){return`XMTP : Enable Identity\n${j(e)}\n\nFor more info: https://xmtp.org/signatures/`}class ns{async newKeystore(e,t,s){if(!s)throw new lt("Wallet required to generate new keys");e.preCreateIdentityCallback&&await e.preCreateIdentityCallback();const n=await He.generate(s),r=new es(s,new Jt(t),e.preEnableIdentityCallback);return await r.storePrivateKeyBundle(n),Xt.create(n,await Qt(e,n))}}class rs{async newKeystore(e,t,s){if(!s)throw new lt("No wallet provided");const n=new es(s,new Jt(t),e.preEnableIdentityCallback),r=await n.loadPrivateKeyBundle();if(!r)throw new lt("No keys found");return Xt.create(r,await Qt(e,r))}}function is(){return window.ethereum}function as(e){const[t,s,...n]=e.split(".");return{major:Number(t),minor:Number(s),patch:n.join(".")}}function os(e,t){if(!e||!t)return!1;const s=as(e),n=as(t);return s.major!==n.major?s.major>n.major:s.minor!==n.minor?s.minor>n.minor:!(!s.patch||!n.patch)&&function(e,t){const[s,n]=e.split("-"),[r,i]=t.split("-");if(Number(s)!==Number(r))return Number(s)>Number(r);if(!n||!i)return!1;const[a,o]=n.split("."),[c,d]=i.split(".");if(a!==c)return!0;return Number(o)>Number(d)}(s.patch,n.patch)}const{GetKeystoreStatusResponse_KeystoreStatus:cs,InitKeystoreRequest:ds,InitKeystoreResponse:hs,GetKeystoreStatusRequest:ys,GetKeystoreStatusResponse:us}=i;async function ls(e,t,s,n,r){let i=null;if(t.req){const e=(0,t.req.encode)(s).finish();i=le(e,0,e.length)}const a=await async function(e,t,s,n){const r={meta:s};"string"==typeof t&&(r.req=t);const i=await(is()?.request({method:"wallet_invokeSnap",params:{snapId:n,request:{method:e,params:r}}}));if(!i||"object"!=typeof i)throw new Error("No response value");return i.res}(e,i,n,r);if(Array.isArray(a))throw new Error("Unexpected array response");return t.res.decode(ue(a))}async function ps(){const e=is();if(e?.isMetaMask)try{return await e.request({method:"wallet_getSnaps"}),!0}catch{}if(void 0!==e?.detected&&Array.isArray(e.detected))for(const t of e.detected)try{return await t.request({method:"wallet_getSnaps"}),e?.setProvider?.(t),!0}catch{}if(void 0!==e?.providers&&Array.isArray(e.providers))for(const t of e.providers)try{return await t.request({method:"wallet_getSnaps"}),window.ethereum=t,!0}catch{}return!1}async function ws(e,t){try{const s=await async function(){return await(is()?.request({method:"wallet_getSnaps"}))}();return s?Object.values(s).find((s=>{return s&&s.id===e&&(!t||(n=s.version,r=t,!n||!r||as(n).major===as(r).major));var n,r})):void 0}catch(e){return void console.warn("Failed to obtain installed snap",e)}}const fs={req:ys,res:us};const ms={req:ds,res:hs};const gs={decryptV1:{req:i.DecryptV1Request,res:i.DecryptResponse},decryptV2:{req:i.DecryptV2Request,res:i.DecryptResponse},encryptV1:{req:i.EncryptV1Request,res:i.EncryptResponse},encryptV2:{req:i.EncryptV2Request,res:i.EncryptResponse},saveInvites:{req:i.SaveInvitesRequest,res:i.SaveInvitesResponse},createInvite:{req:i.CreateInviteRequest,res:i.CreateInviteResponse},createAuthToken:{req:i.CreateAuthTokenRequest,res:c.Token},signDigest:{req:i.SignDigestRequest,res:s.Signature},getPublicKeyBundle:{req:null,res:n.PublicKeyBundle},getPrivateKeyBundle:{req:null,res:t.PrivateKeyBundleV1},saveV1Conversations:{req:i.SaveV1ConversationsRequest,res:i.SaveV1ConversationsResponse},getV1Conversations:{req:null,res:i.GetConversationsResponse},getV2Conversations:{req:null,res:i.GetConversationsResponse},getRefreshJob:{req:i.GetRefreshJobRequest,res:i.GetRefreshJobResponse},setRefreshJob:{req:i.SetRefeshJobRequest,res:i.SetRefreshJobResponse},selfEncrypt:{req:i.SelfEncryptRequest,res:i.SelfEncryptResponse},selfDecrypt:{req:i.SelfDecryptRequest,res:i.DecryptResponse},getPrivatePreferencesTopicIdentifier:{req:null,res:i.GetPrivatePreferencesTopicIdentifierResponse},getV2ConversationHmacKeys:{req:i.GetConversationHmacKeysRequest,res:i.GetConversationHmacKeysResponse}},vs={...gs,getKeystoreStatus:{req:i.GetKeystoreStatusRequest,res:i.GetKeystoreStatusResponse},initKeystore:{req:i.InitKeystoreRequest,res:i.InitKeystoreResponse}};const{GetKeystoreStatusResponse_KeystoreStatus:bs}=i;class Es{constructor(e="local:http://localhost:8080",t){this.snapId=e,this.snapVersion=t}async newKeystore(e,t,s){if(!s)throw new lt("No wallet provided");if(!await ps())throw new lt("MetaMask with Snaps not detected");const n=await s.getAddress(),r=e.env,i=await ws(this.snapId,this.snapVersion);if(i&&!os(this.snapVersion,i.version)||await async function(e,t={}){await(is()?.request({method:"wallet_requestSnaps",params:{[e]:t}}))}(this.snapId,this.snapVersion?{version:this.snapVersion}:{}),!await async function(e,t,s){const n=await async function(e,t){const s=await ls("getKeystoreStatus",fs,{walletAddress:e.walletAddress},e,t);if([cs.KEYSTORE_STATUS_UNSPECIFIED,cs.UNRECOGNIZED].includes(s.status))throw new Error("No status specified in response");return s.status}({walletAddress:e,env:t},s);if(n===bs.KEYSTORE_STATUS_INITIALIZED)return!0;return!1}(n,r,this.snapId)){const n=await async function(e,t,s){if(e.privateKeyOverride){const t=Fe(e.privateKeyOverride);if(!(t instanceof He))throw new Error("Unsupported private key bundle version");return t}if(!s)throw new Error("No privateKeyOverride or wallet");return async function(e,t,s){const n=new rs;try{const r=await n.newKeystore(e,t,s);return new He(await r.getPrivateKeyBundle())}catch(n){if(n instanceof lt)return async function(e,t,s){const n=new ns,r=await n.newKeystore(e,t,s);return new He(await r.getPrivateKeyBundle())}(e,t,s);throw n}}(e,t,s)}(e,t,s);await async function(e,t,s){const n=e.identityKey.publicKey.walletSignatureAddress(),r=await ls("initKeystore",ms,{v1:e},{walletAddress:n,env:t},s);if(r.error)throw new ve(r.error.code,r.error.message)}(n,r,this.snapId)}return function(e,t,s){const n={},r={walletAddress:e,env:t};for(const[e,t]of Object.entries(vs))n[e]=async n=>t.req?ls(e,t,n,r,s):ls(e,t,void 0,r,s);return{...n,getAccountAddress:async()=>e}}(n,r,this.snapId)}}class Ks{async newKeystore(e){const{privateKeyOverride:t}=e;if(!t)throw new lt("No private key override provided");const s=Fe(t);if(s instanceof Le)throw new Error("V2 private key bundle found. Only V1 supported");return Xt.create(s,await Qt(e,s))}}function As(e){if(!e)return null;if(function(e){return"type"in e&&("walletClient"===e.type||"base"===e.type)}(e))return function(e){const{account:t}=e;if(!t||!t.address)throw new Error("WalletClient is not configured");return{getAddress:async()=>t.address,signMessage:async s=>e.signMessage({message:"string"==typeof s?s:{raw:s},account:t})}}(e);if("function"!=typeof e.getAddress)throw new Error("Unknown wallet type");return e}function ks(e){if(e===o.Compression.COMPRESSION_GZIP)return"gzip";if(e===o.Compression.COMPRESSION_DEFLATE)return"deflate";throw new Error("unrecognized compression algorithm")}function Ts(e,t=1024){let s=0;return new ReadableStream({pull(n){if(s>=e.length)return n.close();let r=s+t;r=r<=e.length?r:e.length,n.enqueue(e.subarray(s,r)),s=r}})}function Ss(e,t){let s=0;return new WritableStream({write(n){const r=s+n.length;if(r>t)throw new Error("maximum output size exceeded");for(;e.bytes.length<r;)e.bytes=Cs(e.bytes,t);e.bytes.set(n,s),s=r},close(){s<e.bytes.length&&(e.bytes=e.bytes.subarray(0,s))}})}function Cs(e,t){let s=2*e.length;s>t&&(s=t);const n=new Uint8Array(s);return n.set(e),n}function Ps(e){let t;try{t=y.ContactBundle.decode(e)}catch(s){const r=n.PublicKeyBundle.decode(e);t={v1:{keyBundle:new de(r)},v2:void 0}}if(t.v1?.keyBundle)return new de(t.v1.keyBundle);if(t.v2?.keyBundle)return new ce(t.v2.keyBundle);throw new Error("unknown or invalid contact bundle")}function Bs(e){return e instanceof de?y.ContactBundle.encode({v1:{keyBundle:e},v2:void 0}).finish():y.ContactBundle.encode({v1:void 0,v2:{keyBundle:e}}).finish()}class Is{constructor(e,t,s){this.value=e,this.entryType=t,this.permissionType=s}get key(){return`${this.entryType}-${this.value}`}static fromAddress(e,t="unknown"){return new Is(e,"address",t)}}class Rs{constructor(e){this.entries=new Map,this.client=e}allow(e){const t=Is.fromAddress(e,"allowed");return this.entries.set(t.key,"allowed"),t}deny(e){const t=Is.fromAddress(e,"denied");return this.entries.set(t.key,"denied"),t}state(e){const t=Is.fromAddress(e);return this.entries.get(t.key)??"unknown"}async getIdentifier(){if(!this._identifier){const{identifier:e}=await this.client.keystore.getPrivatePreferencesTopicIdentifier();this._identifier=e}return this._identifier}async decodeMessages(e){const{responses:t}=await this.client.keystore.selfDecrypt({requests:e.map((e=>({payload:e})))});return t.reduce(((e,t)=>t.result?.decrypted?e.concat(u.PrivatePreferencesAction.decode(t.result.decrypted)):e),[])}processActions(e,t){const s=[];return e.forEach((e=>{e.allowAddress?.walletAddresses.forEach((e=>{s.push(this.allow(e))})),e.denyAddress?.walletAddresses.forEach((e=>{s.push(this.deny(e))}))})),t&&(this.lastEntryTimestamp=ge(t)),s}async stream(e){const t=await this.getIdentifier(),s=Be(t);return ye.create(this.client,[s],(async e=>{if(!e.message)return;const t=await this.decodeMessages([e.message]);return this.processActions(t,e.timestampNs),t[0]}),void 0,e)}reset(){this.entries.clear()}async load(e){const t=await this.getIdentifier(),s=Be(t);let n;const r=await this.client.listEnvelopes(s,(async({message:e,timestampNs:t})=>(t&&(n=t),e)),{startTime:e}),i=await this.decodeMessages(r);return this.processActions(i,n)}async publish(e){const t=await this.getIdentifier(),s=e.reduce(((e,t)=>{if("address"===t.entryType){const s={allowAddress:"allowed"===t.permissionType?{walletAddresses:[t.value]}:void 0,denyAddress:"denied"===t.permissionType?{walletAddresses:[t.value]}:void 0,allowGroup:void 0,denyGroup:void 0};return e.concat(u.PrivatePreferencesAction.encode(s).finish())}return e}),[]),{responses:n}=await this.client.keystore.selfEncrypt({requests:s.map((e=>({payload:e})))}),r=n.reduce(((e,t)=>t.result?.encrypted?e.concat(t.result?.encrypted):e),[]),i=Be(t),a=new Date,o=r.map((e=>({contentTopic:i,message:e,timestamp:a})));await this.client.publishEnvelopes(o),e.forEach((e=>{this.entries.set(e.key,e.permissionType)}))}}class Ns{constructor(e){this.addresses=new Set,this.consentList=new Rs(e),this.client=e,this.jobRunner=new ot("user-preferences",e.keystore)}validateConsentSignature({signature:e,timestamp:t},s){const n=Number(t);if(!e||!n)return!1;if(n>Date.now())return!1;if(n<Date.now()-2592e6)return!1;const r=J(e),i=R(s,n),a=ee(v(b(i)),r);return a?.getEthereumAddress()===this.client.address}async loadConsentList(e){return this.jobRunner.run((async t=>{const s=await this.consentList.load(e??t);try{const e=(await this.client.conversations.list()).reduce(((e,t)=>t.consentProof&&"unknown"===this.consentState(t.peerAddress)&&this.validateConsentSignature(t.consentProof,t.peerAddress)?e.concat(t.peerAddress):e),[]);e.length&&await this.client.contacts.allow(e)}catch(e){console.log(e)}return s}))}async refreshConsentList(){return this.consentList.reset(),await this.jobRunner.resetLastRunTime(),this.loadConsentList()}async streamConsentList(e){return this.consentList.stream(e)}get lastConsentListEntryTimestamp(){return this.consentList.lastEntryTimestamp}setConsentListEntries(e){e.length&&(this.consentList.reset(),e.forEach((e=>{"allowed"===e.permissionType&&this.consentList.allow(e.value),"denied"===e.permissionType&&this.consentList.deny(e.value)})))}isAllowed(e){return"allowed"===this.consentList.state(e)}isDenied(e){return"denied"===this.consentList.state(e)}consentState(e){return this.consentList.state(e)}async allow(e){await this.consentList.publish(e.map((e=>Is.fromAddress(e,"allowed"))))}async deny(e){await this.consentList.publish(e.map((e=>Is.fromAddress(e,"denied"))))}}var Ds;!function(e){e[e.none=0]="none",e[e.xmtpTopicStore=1]="xmtpTopicStore"}(Ds||(Ds={}));const Ms=Ds.none;class _s{static createConfiguration(){return{type:Ms,version:0}}constructor(e){this.configuration=e}get backupType(){return Ms}}const xs=Ds.xmtpTopicStore;class Vs{static createConfiguration(e){return{type:xs,version:0,topic:"history-v0:"+e}}constructor(e){this.configuration=e}get backupType(){return xs}}async function Us(e,t){const s=await async function(e,t){let s;switch((await t()).type){case Ds.none:s=_s.createConfiguration();break;case Ds.xmtpTopicStore:s=Vs.createConfiguration(e)}return s}(e,t);switch(s.type){case Ds.none:return new _s(s);case Ds.xmtpTopicStore:return new Vs(s)}}const{Compression:qs}=o,Os=104857600;class Ls{constructor(e,t,s,n){this.knownPublicKeyBundles=new Map,this.keystore=n,this.publicKeyBundle=e,this.address=e.walletSignatureAddress(),this._conversations=new dt(this),this._codecs=new Map,this._maxContentSize=Os,this.apiClient=t,this._backupClient=s,this.contacts=new Ns(this)}get conversations(){return this._conversations}get backupType(){return this._backupClient.backupType}get signedPublicKeyBundle(){return ce.fromLegacyBundle(this.publicKeyBundle)}static async create(e,t){const s=As(e),n=function(e){const t={privateKeyOverride:void 0,env:"dev",apiUrl:void 0,codecs:[new A],maxContentSize:Os,persistConversations:!0,skipContactPublishing:!1,useSnaps:!1,basePersistence:"undefined"!=typeof window&&void 0!==window.document?ht.create():ut.create(),disablePersistenceEncryption:!1,keystoreProviders:$s(),apiClientFactory:Hs};return e?.codecs&&(e.codecs=t.codecs.concat(e.codecs)),e?.useSnaps&&(e.keystoreProviders=[new Es("npm:@xmtp/snap","1.3.6"),...t.keystoreProviders]),{...t,...e}}(t),r=n.apiClientFactory(n),i=await async function(e,t,s){for(const n of e.keystoreProviders)try{return await n.newKeystore(e,t,s??void 0)}catch(e){if(e instanceof lt)continue;throw e}throw new Error("No keystore providers available")}(n,r,s),a=new de(await i.getPublicKeyBundle()),o=a.walletSignatureAddress();r.setAuthenticator(new je(i));const c=await Ls.setupBackupClient(o,n.env),d=new Ls(a,r,c,i);return await d.init(n),d}static async getKeys(e,t){const s=await Ls.create(As(e),t),n=await s.keystore.getPrivateKeyBundle();return new He(n).encode()}static isSnapsReady(){return ps()}static async setupBackupClient(e,t){return Us(e,(async()=>Promise.resolve({type:"local"===t?Ds.xmtpTopicStore:Ds.none})))}async init(e){e.codecs.forEach((e=>{this.registerCodec(e)})),this._maxContentSize=e.maxContentSize,e.skipContactPublishing||await this.ensureUserContactPublished(e.publishLegacyContact)}async close(){}async ensureUserContactPublished(e=!1){const t=await Fs(this.apiClient,this.address);t&&t instanceof ce&&this.signedPublicKeyBundle.equals(t)||(await this.publishUserContact(!0),e||await this.publishUserContact(e))}async publishUserContact(e=!1){const t=e?this.publicKeyBundle:this.signedPublicKeyBundle;await this.publishEnvelopes([{contentTopic:Te(this.address),message:Bs(t)}])}async getUserContact(e){e=m(e);const t=this.knownPublicKeyBundles.get(e);if(t)return t;const s=await Fs(this.apiClient,e);return s&&this.knownPublicKeyBundles.set(e,s),s}async getUserContacts(e){const t=e.map((e=>m(e))),s=new Map,n=[];for(const e of t){const t=this.knownPublicKeyBundles.get(e);t?s.set(e,t):(s.set(e,void 0),n.push(e))}const r=await Gs(this.apiClient,n);for(let e=0;e<r.length;e++){const t=n[e],i=r[e];s.set(t,i),i&&this.knownPublicKeyBundles.set(t,i)}return t.map((e=>s.get(e)))}forgetContact(e){e=m(e),this.knownPublicKeyBundles.delete(e)}async canMessage(e){try{if(Array.isArray(e)){return(await this.getUserContacts(e)).map((e=>!!e))}return void 0!==await this.getUserContact(e)}catch(e){return!1}}static async canMessage(e,t){const s=t?.apiUrl||et[t?.env||"dev"],n=new at(s,{appVersion:t?.appVersion});if(Array.isArray(e)){const t=e.map((e=>m(e)));return(await Gs(n,t)).map((e=>!!e))}try{e=m(e)}catch(e){return!1}return void 0!==await Fs(n,e)}validateEnvelope(e){const t=e.message;if(!e.contentTopic)throw new Error("Missing content topic");if(!t||!t.length)throw new Error("Cannot publish empty message")}async publishEnvelopes(e){for(const t of e)this.validateEnvelope(t);await this.apiClient.publish(e)}registerCodec(e){const t=e.contentType,s=`${t.authorityId}/${t.typeId}`;return this._codecs.set(s,e),this}codecFor(e){const t=`${e.authorityId}/${e.typeId}`,s=this._codecs.get(t);if(s&&!(e.versionMajor>s.contentType.versionMajor))return s}async encodeContent(e,t){const s=t?.contentType||K,n=this.codecFor(s);if(!n)throw new Error("unknown content type "+s);const r=n.encode(e,this),i=n.fallback(e);return i&&(r.fallback=i),"number"==typeof t?.compression&&r.content.length>=10&&(r.compression=t.compression),await async function(e){if(void 0===e.compression)return;const t={bytes:new Uint8Array(e.content.length/10)};await Ts(e.content).pipeThrough(new CompressionStream(ks(e.compression))).pipeTo(Ss(t,e.content.length+1e3)),e.content=t.bytes}(r),{payload:o.EncodedContent.encode(r).finish(),shouldPush:n.shouldPush(e)}}async decodeContent(e){const t=o.EncodedContent.decode(e);if(!t.type)throw new Error("missing content type");let s;const n=new k(t.type);let r;await async function(e,t){if(void 0===e.compression)return;const s={bytes:new Uint8Array(e.content.length)};await Ts(e.content).pipeThrough(new DecompressionStream(ks(e.compression))).pipeTo(Ss(s,t)),e.content=s.bytes}(t,1e3);const i=this.codecFor(n);return i?s=i.decode(t,this):r=new Error("unknown content type "+n),{content:s,contentType:n,error:r,contentFallback:t.fallback}}listInvitations(e){return this.listEnvelopes(Ce(this.address),(async e=>e),e)}async listEnvelopes(e,t,s){s||(s={});const{startTime:n,endTime:r,limit:i}=s,a=await this.apiClient.query({contentTopic:e,startTime:n,endTime:r},{direction:s.direction||d.SortDirection.SORT_DIRECTION_ASCENDING,limit:i}),o=[];for(const e of a)if(e.message)try{const s=await t(e);o.push(s)}catch(e){console.warn("Error in listEnvelopes mapper",e)}return o}listEnvelopesPaginated(e,t,s){return Ye(this.apiClient.queryIteratePages({contentTopic:e,startTime:s?.startTime,endTime:s?.endTime},{direction:s?.direction,pageSize:s?.pageSize||100}),t)}}function Hs(e){const t=e.apiUrl||et[e.env];return new at(t,{appVersion:e.appVersion})}async function Fs(e,t){const s=e.queryIterator({contentTopic:Te(t)},{pageSize:5,direction:Ze.SORT_DIRECTION_DESCENDING});for await(const e of s){if(!e.message)continue;const s=Ps(e.message);let n;try{n=await(s?.walletSignatureAddress())}catch(e){n=void 0}if(n?.toLowerCase()===t.toLowerCase())return s}}async function Gs(e,t){const s=t.map(Te),n=await e.batchQuery(s.map((e=>({contentTopic:e,pageSize:5,direction:Ze.SORT_DIRECTION_DESCENDING}))));return Promise.all(t.map((async(e,t)=>{const s=n[t];if(s)for(const t of s)if(t.message)try{const s=Ps(t.message),n=await(s?.walletSignatureAddress());if(e.toLowerCase()===n.toLowerCase())return s;console.info("Received contact bundle with incorrect address")}catch(e){console.info("Invalid contact bundle",e)}})))}function $s(){return[new Ks,new rs,new ns]}export{et as ApiUrls,We as AuthCache,ht as BrowserStoragePersistence,N as Ciphertext,Ls as Client,qs as Compression,Is as ConsentListEntry,Re as ConversationV1,Ne as ConversationV2,dt as Conversations,Ve as DecodedMessage,Yt as EncryptedPersistence,at as HttpApiClient,Xt as InMemoryKeystore,ut as InMemoryPersistence,Nt as InvitationV1,ns as KeyGeneratorKeystoreProvider,pt as LocalAuthenticator,_e as MessageV1,xe as MessageV2,rs as NetworkKeystoreProvider,Wt as PrefixedPersistence,W as PrivateKey,He as PrivateKeyBundleV1,Le as PrivateKeyBundleV2,oe as PublicKey,de as PublicKeyBundle,_t as SealedInvitation,te as Signature,ae as SignedPublicKey,ce as SignedPublicKeyBundle,Es as SnapProvider,Ze as SortDirection,Ks as StaticKeystoreProvider,ye as Stream,Ke as buildContentTopic,Ae as buildDirectMessageTopic,ke as buildDirectMessageTopicV2,Te as buildUserContactTopic,Se as buildUserIntroTopic,Ce as buildUserInviteTopic,Pe as buildUserPrivateStoreTopic,we as dateToNs,Ps as decodeContactBundle,qe as decodeContent,U as decrypt,$s as defaultKeystoreProviders,V as encrypt,G as exportHmacKey,ge as fromNanoString,H as generateHmacSignature,L as hkdfHmacKey,$ as importHmacKey,gs as keystoreApiDefs,Ye as mapPaginatedStream,fe as nsToDate,ze as retry,vs as snapKeystoreApiDefs,me as toNanoString,F as verifyHmacSignature};
//# sourceMappingURL=index.js.map
